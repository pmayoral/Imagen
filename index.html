<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Im√°genes Profesional</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=PT+Sans+Narrow:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --accent: #007acc;
            --accent-hover: #005a9e;
            --border: #555555;
            --success: #4caf50;
            --warning: #ff9800;
            --error: #f44336;
        }

        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e0e0e0;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border: #cccccc;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding-bottom: 24px; /* Espacio para la barra de estado fija */
        }

        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 50px;
        }

        .logo {
            font-size: 18px;
            font-weight: bold;
            color: var(--accent);
        }

        .header-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }



        .btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--accent);
            border-color: var(--accent);
        }

        .btn.primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        .btn.primary:hover {
            background: var(--accent-hover);
        }

        /* Main Layout */
        .main-content {
            flex: 1;
            display: flex;
            overflow-x: visible;
            overflow-y: hidden;
            position: relative;
        }

        /* Toolbar */
        .toolbar {
            width: 60px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 8px;
            gap: 4px;
            position: relative;
            overflow: visible;
            z-index: 1;
        }

        .tool-btn {
            width: 44px;
            height: 44px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s;
            position: relative;
        }

        .tool-btn:hover {
            background: var(--accent);
            transform: translateY(-1px);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, var(--accent), #0066cc);
            border-color: var(--accent);
            color: white;
            box-shadow: 0 3px 12px rgba(0, 123, 255, 0.4);
            transform: translateY(-1px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .tool-btn.active:hover {
            background: linear-gradient(135deg, #0066cc, var(--accent));
            box-shadow: 0 4px 16px rgba(0, 123, 255, 0.5);
            transform: translateY(-2px);
        }

        /* Simple and Working Tooltips */
        .tool-btn {
            position: relative;
        }

        .tool-btn .tooltip {
            position: absolute;
            left: calc(100% + 10px);
            top: 50%;
            transform: translateY(-50%);
            background: #2d2d2d;
            border: 1px solid #555;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 9999;
            color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .tool-btn:hover .tooltip {
            opacity: 1;
        }

        /* Simple tooltip arrow */
        .tool-btn .tooltip::before {
            content: '';
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            border: 5px solid transparent;
            border-right-color: #2d2d2d;
        }

        /* Text Style Buttons */
        .text-style-btn {
            font-weight: bold;
            min-width: 32px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #textBold.active {
            background: var(--accent);
            color: white;
        }

        #textItalic {
            font-style: italic;
        }

        #textItalic.active {
            background: var(--accent);
            color: white;
        }

        #textUnderline {
            text-decoration: underline;
        }

        #textUnderline.active {
            background: var(--accent);
            color: white;
        }

        /* Text alignment buttons */
        .text-align-btn.active {
            background: var(--accent);
            color: white;
        }

        /* Text modal improvements */
        #textModal .modal-content {
            max-width: 600px;
            width: 90%;
        }

        #textInput {
            font-family: inherit;
            line-height: 1.4;
        }

        #textPreview {
            min-height: 60px;
            overflow-wrap: break-word;
        }

        /* Canvas Area */
        .canvas-container {
            background: #1e1e1e; /* Fondo m√°s oscuro para contrastar con el blanco */
            flex: 1;
            background: var(--bg-primary);
            position: relative;
            overflow: auto;
            scroll-behavior: smooth;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-wrapper {
            box-shadow: 0 0 0 1000px rgba(0,0,0,0.1); /* Sombra masiva para ver l√≠mites */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid var(--border);
            background: #ffffff;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transform-origin: center center;
        }

        #mainCanvas {
            overflow: visible;
            display: block;
            cursor: crosshair;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            border: 2px dashed var(--accent);
            display: none;
        }

        /* Properties Panel */
        .properties-panel {
            width: 220px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel-section {
            border-bottom: 1px solid var(--border);
            padding: 16px;
        }

        .panel-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: margin-bottom 0.3s ease;
        }

        .panel-title:hover {
            color: var(--text-primary);
        }

        .panel-toggle-btn {
            background: transparent;
            border: none;
            color: inherit;
            font-size: 18px;
            padding: 0;
            line-height: 1;
            transition: transform 0.3s ease;
            transform-origin: center;
        }

        .panel-content {
            display: block;
            overflow: hidden;
            max-height: 2000px; /* Adjust if content is taller */
            transition: max-height 0.4s ease-in-out, padding-top 0.4s ease-in-out, opacity 0.3s ease;
            padding-top: 12px;
            opacity: 1;
        }

        .panel-section.collapsed .panel-content {
            max-height: 0;
            padding-top: 0;
            opacity: 0;
        }
        
        .panel-section.collapsed .panel-title {
            margin-bottom: 0;
        }

        .panel-section.collapsed .panel-toggle-btn {
            transform: rotate(-90deg);
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
            color: var(--text-secondary);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Estilos para el men√∫ flotante de reemplazo de color */
        #colorReplaceFloatingMenu {
            animation: colorReplaceMenuFadeIn 0.3s ease-out;
        }

        @keyframes colorReplaceMenuFadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Estilos para el slider de tolerancia */
        #toleranceSlider {
            background: linear-gradient(to right, #ff6b6b, #4ecdc4);
            border-radius: 10px;
        }

        #toleranceSlider::-webkit-slider-thumb {
            background: white;
            border: 2px solid var(--accent);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }

        #toleranceSlider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        /* Estilos para displays de color */
        #sourceColorDisplay, #targetColorDisplay {
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #sourceColorDisplay:hover, #targetColorDisplay:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        }

        /* Animaci√≥n para el indicador de vista previa */
        @keyframes previewPulse {
            0%, 100% {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }
            50% {
                opacity: 0.8;
                transform: translateX(-50%) scale(1.05);
            }
        }

        /* Estilos para las teclas en el panel de ayuda */
        kbd {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 11px;
            font-family: monospace;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }



        .slider-value {
            min-width: 35px;
            font-size: 11px;
            text-align: right;
            color: var(--text-secondary);
        }

        .input-group {
            display: flex;
            gap: 4px;
        }

        .input {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            width: 100%;
        }

        .input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .color-picker {
            width: 40px;
            height: 30px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .color-picker input {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 50px;
            height: 40px;
            border: none;
            background: none;
            cursor: pointer;
        }

        /* Color Palette */
        .color-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            margin-bottom: 8px;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: var(--accent);
        }

        .color-swatch.active {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent);
        }
        
        /* Estilos para bot√≥n activo del cuentagotas */
        .btn.active {
            background: var(--primary) !important;
            color: white !important;
            border-color: var(--primary) !important;
            box-shadow: 0 0 10px var(--primary) !important;
        }
        
        /* Animaciones para notificaciones */
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* Arrow handles */
        .arrow-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--accent);
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.2s ease;
        }

        .arrow-handle:hover {
            background: var(--accent-hover);
            transform: scale(1.2);
        }

        .arrow-handle.start { cursor: move; }
        .arrow-handle.end { cursor: ne-resize; }
        .arrow-handle.control { cursor: grab; }
        .arrow-handle.control:active { cursor: grabbing; }

        /* Text handles */
        .text-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #ff6b35;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            z-index: 15;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.2s ease;
        }

        .text-handle:hover {
            background: #ff4500;
            transform: scale(1.3);
        }

        .text-handle.move { cursor: move; background: #4CAF50; }
        .text-handle.resize-nw { cursor: nw-resize; }
        .text-handle.resize-ne { cursor: ne-resize; }
        .text-handle.resize-sw { cursor: sw-resize; }
        .text-handle.resize-se { cursor: se-resize; }
        .text-handle.edit { cursor: pointer; background: #2196F3; }

        /* Text selection outline */
        .text-selection-outline {
            position: absolute;
            border: 2px dashed #ff6b35;
            background: rgba(255, 107, 53, 0.1);
            pointer-events: none;
            z-index: 14;
        }

        /* Shape handles */
        .shape-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #2196F3;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            z-index: 15;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.2s ease;
        }

        .shape-handle:hover {
            background: #1976D2;
            transform: scale(1.3);
        }

        .shape-handle.nw, .shape-handle.se { cursor: nw-resize; }
        .shape-handle.ne, .shape-handle.sw { cursor: ne-resize; }

        /* Floating Panels */
        .floating-panel {
            position: fixed !important;
            background: var(--bg-secondary) !important;
            border: 1px solid var(--border) !important;
            border-radius: 8px !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4) !important;
            padding: 16px !important;
            z-index: 2000 !important;
            display: none !important;
            min-width: 200px !important;
            max-width: 400px !important;
            opacity: 1 !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }

        .floating-panel.show {
            display: block !important;
            visibility: visible !important;
            pointer-events: auto !important;
            opacity: 1 !important;
        }




        .progress-fill {
            height: 100% !important;
            background: linear-gradient(90deg, #2ecc71, #27ae60) !important;
            width: 0% !important;
            transition: width 0.3s ease !important;
            position: relative !important;
        }

        .progress-fill::after {
            content: '' !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent) !important;
            animation: progress-shine 2s infinite !important;
        }

        @keyframes progress-shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            text-align: center !important;
            color: white !important;
            font-weight: bold !important;
            margin-top: 8px !important;
            font-size: 13px !important;
        }

        .config-row {
            display: flex !important;
            gap: 12px !important;
            align-items: center !important;
            margin-bottom: 12px !important;
        }

        .config-row label {
            min-width: 80px !important;
            font-size: 13px !important;
        }

        .config-row input, .config-row select {
            flex: 1 !important;
            padding: 8px !important;
            border: 1px solid rgba(255,255,255,0.3) !important;
            border-radius: 4px !important;
            background: rgba(255,255,255,0.9) !important;
            color: #333 !important;
            font-size: 13px !important;
        }

        .config-row input::placeholder {
            color: rgba(51,51,51,0.7) !important;
        }

        .config-row select option {
            background: white !important;
            color: #333 !important;
        }

        /* Estilos espec√≠ficos para el panel de formas */
        #shapesPanel {
            width: 320px !important;
            max-height: 500px !important;
            overflow-y: auto !important;
        }

        .floating-panel h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Quick Color Palette */
        .quick-color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }

        .quick-color-swatch {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .quick-color-swatch:hover {
            transform: scale(1.1);
            border-color: var(--accent);
        }

        .quick-color-swatch.active {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent);
        }

        /* Thickness Panel */
        .thickness-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .thickness-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .thickness-option:hover {
            background: var(--bg-tertiary);
        }

        .thickness-option.active {
            background: var(--accent);
            color: white;
        }

        .thickness-preview {
            width: 40px;
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .thickness-preview::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            background: var(--text-primary);
            border-radius: 10px;
            transform: translateY(-50%);
        }

        .thickness-preview[data-size="1"]::after { height: 1px; }
        .thickness-preview[data-size="3"]::after { height: 3px; }
        .thickness-preview[data-size="5"]::after { height: 5px; }
        .thickness-preview[data-size="8"]::after { height: 8px; }
        .thickness-preview[data-size="12"]::after { height: 12px; }
        .thickness-preview[data-size="20"]::after { height: 20px; }



        /* Filters Grid */
        .filters-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .filter-preset {
            aspect-ratio: 1;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            text-align: center;
            transition: all 0.2s;
        }

        .filter-preset:hover {
            background: var(--accent);
            transform: scale(1.05);
        }

        /* Layers Panel */
        .layers-list {
            min-height: 100px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            padding: 8px;
        }

        .layer-item {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 8px;
            margin-bottom: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
        }

        .layer-item.active {
            border-color: var(--accent);
            background: rgba(0, 122, 204, 0.1);
        }

        .layer-thumb {
            width: 24px;
            height: 24px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            flex-shrink: 0;
        }

        /* Histogram */
        .histogram-container {
            height: 80px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        #histogramCanvas {
            width: 100%;
            height: 100%;
        }

        /* Status Bar */
        .status-bar {
            height: 26px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 11px;
            color: var(--text-secondary);
            gap: 12px;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
            overflow-x: auto;
            white-space: nowrap;
        }

        .status-separator {
            color: var(--border);
            font-weight: bold;
            user-select: none;
        }

        /* Modal Dialogs */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .modal-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        /* Drop Zone */
        .drop-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 200px;
            border: 2px dashed var(--border);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: var(--text-secondary);
            transition: all 0.3s;
        }

        .drop-zone.drag-over {
            border-color: var(--accent);
            background: rgba(0, 122, 204, 0.1);
        }

        .drop-zone h3 {
            margin-bottom: 8px;
            font-size: 18px;
        }

        .drop-zone p {
            font-size: 12px;
            opacity: 0.7;
        }

        /* Indicador de API moderna */
        .modern-api-indicator {
            font-size: 0.8em;
            color: #4CAF50;
            opacity: 0.8;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .properties-panel {
                width: 240px;
            }
        }

        @media (max-width: 768px) {
            .toolbar {
                width: 50px;
            }
            
            .tool-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            .properties-panel {
                position: absolute;
                right: -280px;
                top: 0;
                bottom: 0;
                z-index: 100;
                transition: right 0.3s;
            }
            
            .properties-panel.open {
                right: 0;
            }
        }

        /* Animation Classes */
        .fade-in { animation: fadeIn 0.3s ease; }
        .processing { cursor: wait !important; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }



        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Help Modal Styles */
        .help-section {
            margin-bottom: 24px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border-left: 4px solid var(--accent);
        }

        .help-section h3 {
            color: var(--accent);
            font-size: 16px;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .help-section h4 {
            color: var(--text-primary);
            font-size: 14px;
            margin: 16px 0 8px 0;
            font-weight: 500;
        }

        .help-section p {
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 12px;
        }

        .help-section ul {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-left: 20px;
        }

        .help-section ol {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-left: 20px;
        }

        .help-section li {
            margin-bottom: 8px;
        }

        .help-section li ul {
            margin-top: 8px;
            margin-bottom: 8px;
        }

        .help-section li ul li {
            margin-bottom: 4px;
        }

        .help-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
            margin-top: 12px;
        }

        .help-item {
            background: var(--bg-primary);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .help-item strong {
            color: var(--text-primary);
            display: block;
            margin-bottom: 6px;
        }

        .help-subsection {
            margin: 16px 0;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        /* Mejor visibilidad de los paneles flotantes */
        .floating-panel.show {
            animation: panelFadeIn 0.3s ease-out;
            box-shadow: 0 12px 36px rgba(0, 0, 0, 0.4) !important;
            backdrop-filter: blur(10px);
        }

        @keyframes panelFadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

    </style>
</head>
<body data-theme="dark">
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="logo">üé® Editor Pro</div>
            <div class="header-controls">
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
                <button class="btn" onclick="newImage()">
                    üÜï Nueva Imagen
                </button>
                <button class="btn" onclick="(function(){const f=document.getElementById('fileInput');if(f)f.click();})()">
                    üìÅ Abrir
                </button>
                <button class="btn" onclick="showSettingsModal()">
                    ‚öôÔ∏è Ajustes
                </button>
                <button class="btn" onclick="saveImage()">üíæ Guardar</button>
                <button class="btn" onclick="exportImage()">üì§ Guardar como<span id="modernApiIndicator" class="modern-api-indicator" style="display: none; margin-left: 4px;" title="Funcionalidad moderna de directorio disponible">üöÄ</span></button>
                <button class="btn" onclick="undo()">‚Ü©Ô∏è Deshacer</button>
                <button class="btn" onclick="redo()">‚Ü™Ô∏è Rehacer</button>
                <button class="btn" onclick="toggleTheme()">üåì Tema</button>
                <button class="btn" onclick="toggleFullscreen()">üî≥ Pantalla Completa</button>
                <button class="btn" onclick="showHelpModal()">‚ùì Ayuda</button>

            </div>
        </header>



        <!-- Main Content -->
        <main class="main-content">
            <!-- Toolbar -->
            <div class="toolbar">
                <div class="tool-btn active" data-tool="select" onclick="selectTool('select')">
                    üîΩ
                    <div class="tooltip">Seleccionar √°reas y mover elementos (V)</div>
                </div>
                <div class="tool-btn" data-tool="crop" onclick="selectTool('crop')">
                    ‚úÇÔ∏è
                    <div class="tooltip">Recortar imagen - Arrastra los puntos para ajustar (C)<br>Enter: aplicar recorte</div>
                </div>
                <div class="tool-btn" data-tool="brush" onclick="selectTool('brush')">
                    üñåÔ∏è
                    <div class="tooltip">Pincel para dibujar y pintar (B)</div>
                </div>
                <div class="tool-btn" data-tool="eraser" onclick="selectTool('eraser')">
                    üßΩ
                    <div class="tooltip">Goma de borrar partes de la imagen (E)</div>
                </div>
                <div class="tool-btn" data-tool="text" onclick="selectTool('text')">
                    T
                    <div class="tooltip">A√±adir texto a la imagen (T)</div>
                </div>
                <div class="tool-btn" data-tool="shapes" onclick="event.stopPropagation(); activateShapesTool();">
                    üü¢
                    <div class="tooltip">Panel de formas geom√©tricas (U)</div>
                </div>
                <div class="tool-btn" data-tool="arrow" onclick="selectTool('arrow')">
                    ‚û°Ô∏è
                    <div class="tooltip">Crear flechas estirables (A)</div>
                </div>
                <div class="tool-btn" data-tool="gradient" onclick="selectTool('gradient')">
                    üåà
                    <div class="tooltip">Aplicar gradientes de color (G)</div>
                </div>
                <div class="tool-btn" data-tool="eyedropper" onclick="selectTool('eyedropper')">
                    üíß
                    <div class="tooltip">Cuentagotas - Indicador flotante en tiempo real (D)</div>
                </div>
                <div class="tool-btn" data-tool="clone" onclick="selectTool('clone')">
                    üë•
                    <div class="tooltip">Clonar partes de la imagen (S)<br>Clic izq: seleccionar √°rea<br>Clic der: pegar<br>Escape: limpiar</div>
                </div>
                <div class="tool-btn" data-tool="heal" onclick="selectTool('heal')">
                    ü©π
                    <div class="tooltip">Reparar y retocar imperfecciones (J)</div>
                </div>
                <div class="tool-btn" data-tool="colorReplace" onclick="selectTool('colorReplace')">
                    üé®üîÑ
                    <div class="tooltip">Reemplazar Color (L)<br>Clic izq: seleccionar color origen<br>Clic der: aplicar reemplazo<br>Tolerancia ajustable</div>
                </div>
                <div class="tool-btn" data-tool="zoom" onclick="selectTool('zoom')">
                    üîç
                    <div class="tooltip">Ampliar o reducir vista (Z)</div>
                </div>
                
                <!-- Separador -->
                <div style="height: 8px; border-bottom: 1px solid var(--border); margin: 4px 0;"></div>
                
                <div class="tool-btn" data-tool="palette" onclick="event.stopPropagation(); toggleColorPalette();">
                    üé®
                    <div class="tooltip">Paleta de Colores (P)</div>
                </div>
                
                <div class="tool-btn" data-tool="thickness" onclick="event.stopPropagation(); toggleThicknessPanel();">
                    üìè
                    <div class="tooltip">Control de Grosor (R)</div>
                </div>
                
            </div>

            <!-- Canvas Area -->
            <div class="canvas-container" id="canvasContainer">
                <div class="drop-zone" id="dropZone">
                    <h3>üìÅ Arrastra una imagen aqu√≠</h3>
                    <p>O haz clic en "Abrir" para seleccionar un archivo</p>
                    <p>Soporta: JPG, PNG, GIF, WEBP, BMP, TIFF</p>
                </div>
                
                <div class="canvas-wrapper" id="canvasWrapper" style="display: none;">
                    <canvas id="mainCanvas"></canvas>
                    <div class="canvas-overlay" id="selectionOverlay"></div>
                </div>
            </div>

            <!-- Properties Panel -->
            <div class="properties-panel">
                <!-- Basic Adjustments -->
                <div class="panel-section">
                    <div class="panel-title" onclick="togglePanel(this)">
                        <span>Ajustes B√°sicos</span>
                        <button class="panel-toggle-btn">‚ñº</button>
                    </div>
                    <div class="panel-content">
                        <div class="control-group">
                            <label class="control-label">‚òÄÔ∏è Brillo</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="brightness" min="-100" max="100" value="0" oninput="updateFilter('brightness', this.value)">
                                <span class="slider-value" id="brightnessValue">0</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">‚ö™ Contraste</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="contrast" min="-100" max="100" value="0" oninput="updateFilter('contrast', this.value)">
                                <span class="slider-value" id="contrastValue">0</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">üåà Saturaci√≥n</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="saturation" min="-100" max="100" value="0" oninput="updateFilter('saturation', this.value)">
                                <span class="slider-value" id="saturationValue">0</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">üé® Matiz</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="hue" min="-180" max="180" value="0" oninput="updateFilter('hue', this.value)">
                                <span class="slider-value" id="hueValue">0</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">üí° Exposici√≥n</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="exposure" min="-200" max="200" value="0" step="1" oninput="updateFilter('exposure', this.value)">
                                <span class="slider-value" id="exposureValue">0</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">üå°Ô∏è Temperatura</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="temperature" min="-100" max="100" value="0" oninput="updateFilter('temperature', this.value)">
                                <span class="slider-value" id="temperatureValue">0</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Filters -->
                <div class="panel-section">
                    <div class="panel-title" onclick="togglePanel(this)">
                        <span>Filtros</span>
                        <button class="panel-toggle-btn">‚ñº</button>
                    </div>
                    <div class="panel-content">
                        <div class="filters-grid">
                            <div class="filter-preset" onclick="applyFilter('original')">Original</div>
                            <div class="filter-preset" onclick="applyFilter('vintage')">Vintage</div>
                            <div class="filter-preset" onclick="applyFilter('bw')">B&N</div>
                            <div class="filter-preset" onclick="applyFilter('sepia')">Sepia</div>
                            <div class="filter-preset" onclick="applyFilter('polaroid')">Polaroid</div>
                            <div class="filter-preset" onclick="applyFilter('warm')">C√°lido</div>
                            <div class="filter-preset" onclick="applyFilter('cool')">Fr√≠o</div>
                            <div class="filter-preset" onclick="applyFilter('dramatic')">Dram√°tico</div>
                            <div class="filter-preset" onclick="applyFilter('soft')">Suave</div>
                        </div>
                    </div>
                </div>

                <!-- Transform -->
                <div class="panel-section">
                    <div class="panel-title" onclick="togglePanel(this)">
                        <span>Transformar</span>
                        <button class="panel-toggle-btn">‚ñº</button>
                    </div>
                    <div class="panel-content">
                        <div class="control-group">
                            <label class="control-label">üîÑ Rotar</label>
                            <div class="input-group">
                                <button class="btn" onclick="rotateImage(-90)">‚Ü∫ 90¬∞</button>
                                <button class="btn" onclick="rotateImage(90)">‚Üª 90¬∞</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">üîÄ Voltear</label>
                            <div class="input-group">
                                <button class="btn" onclick="flipImage('horizontal')">‚ÜîÔ∏è Horizontal</button>
                                <button class="btn" onclick="flipImage('vertical')">‚ÜïÔ∏è Vertical</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">üìè Tama√±o</label>
                            <div class="input-group">
                                <input type="number" class="input" id="canvasWidth" placeholder="Ancho" onchange="resizeCanvas()">
                                <input type="number" class="input" id="canvasHeight" placeholder="Alto" onchange="resizeCanvas()">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Effects -->
                <div class="panel-section">
                    <div class="panel-title" onclick="togglePanel(this)">
                        <span>Efectos</span>
                        <button class="panel-toggle-btn">‚ñº</button>
                    </div>
                    <div class="panel-content">
                        <div class="control-group">
                            <label class="control-label">üåÄ Desenfoque</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="blur" min="0" max="20" value="0" oninput="updateFilter('blur', this.value)">
                                <span class="slider-value" id="blurValue">0</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">üîç Enfoque</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="sharpen" min="0" max="100" value="0" oninput="updateFilter('sharpen', this.value)">
                                <span class="slider-value" id="sharpenValue">0</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">üå´Ô∏è Vi√±eta</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="vignette" min="0" max="100" value="0" oninput="updateFilter('vignette', this.value)">
                                <span class="slider-value" id="vignetteValue">0</span>
                            </div>
                        </div>

                        <div class="control-group">
                            <label class="control-label">üåæ Grano</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="grain" min="0" max="100" value="0" oninput="updateFilter('grain', this.value)">
                                <span class="slider-value" id="grainValue">0</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tool Properties -->
                <div class="panel-section" id="toolProperties">
                    <div class="panel-title" onclick="togglePanel(this)">
                        <span>Propiedades de Herramienta</span>
                        <button class="panel-toggle-btn">‚ñº</button>
                    </div>
                    <div class="panel-content">
                        <div class="control-group" id="brushProperties" style="display: none;">
                            <label class="control-label">üñåÔ∏è Tama√±o del Pincel</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="brushSize" min="1" max="100" value="10" oninput="updateBrushSize(this.value)">
                                <span class="slider-value" id="brushSizeValue">10</span>
                            </div>
                            
                            <label class="control-label">üíé Dureza</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="brushHardness" min="0" max="100" value="100" oninput="updateBrushHardness(this.value)">
                                <span class="slider-value" id="brushHardnessValue">100</span>
                            </div>
                            
                            <label class="control-label">üëª Opacidad</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="brushOpacity" min="0" max="100" value="100" oninput="updateBrushOpacity(this.value)">
                                <span class="slider-value" id="brushOpacityValue">100</span>
                            </div>
                            
                            <label class="control-label">üé® Color</label>
                            <div class="color-picker">
                                <input type="color" id="brushColor" value="#000000" onchange="updateBrushColor(this.value)">
                            </div>
                        </div>

                        <div class="control-group" id="colorReplaceProperties" style="display: none;">
                            <label class="control-label">üéØ Color Origen</label>
                            <div class="color-picker-container" style="display: flex; align-items: center; gap: 8px;">
                                <div class="color-picker">
                                    <input type="color" id="colorReplaceSource" value="#ff0000" onchange="updateColorReplaceSource(this.value)">
                                </div>
                                <button class="btn" onclick="activateColorPickerMode('source')" style="padding: 4px 8px; font-size: 12px;">
                                    üíß Seleccionar
                                </button>
                            </div>
                            
                            <label class="control-label">üé® Color Destino</label>
                            <div class="color-picker-container" style="display: flex; align-items: center; gap: 8px;">
                                <div class="color-picker">
                                    <input type="color" id="colorReplaceTarget" value="#00ff00" onchange="updateColorReplaceTarget(this.value)">
                                </div>
                                <button class="btn" onclick="activateColorPickerMode('target')" style="padding: 4px 8px; font-size: 12px;">
                                    üíß Seleccionar
                                </button>
                            </div>
                            
                            <label class="control-label">üéöÔ∏è Tolerancia</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="colorReplaceTolerance" min="0" max="100" value="10" oninput="updateColorReplaceTolerance(this.value)">
                                <span class="slider-value" id="colorReplaceToleranceValue">10</span>
                            </div>
                            
                            <label class="control-label">üé≠ Modo de Reemplazo</label>
                            <select class="input" id="colorReplaceMode" onchange="updateColorReplaceMode(this.value)">
                                <option value="solid">S√≥lido</option>
                                <option value="gradient">Gradiente Suave</option>
                                <option value="smart">Inteligente</option>
                                <option value="hue">Solo Matiz</option>
                                <option value="saturation">Solo Saturaci√≥n</option>
                            </select>
                            
                            <label class="control-label">üîç Vista Previa</label>
                            <div class="input-group">
                                <button class="btn" onclick="toggleColorReplacePreview()" id="colorReplacePreviewBtn">
                                    üëÅÔ∏è Activar Vista Previa
                                </button>
                                <button class="btn" onclick="applyColorReplace()" style="background: var(--success);">
                                    ‚úÖ Aplicar
                                </button>
                            </div>
                            
                            <div class="control-group" style="margin-top: 10px;">
                                <label class="control-label">ü™Ñ Funciones Avanzadas</label>
                                <div class="input-group">
                                    <button class="btn" onclick="activateMagicWand()" style="background: linear-gradient(45deg, #ff6b6b, #4ecdc4); color: white;">
                                        ü™Ñ Varita M√°gica
                                    </button>
                                    <button class="btn" onclick="showColorHistogram()" style="background: var(--accent);">
                                        üìä Estad√≠sticas
                                    </button>
                                </div>
                            </div>
                            
                            <div class="control-group" style="margin-top: 10px;">
                                <label class="control-label">üìä Informaci√≥n</label>
                                <div id="colorReplaceInfo" style="font-size: 11px; color: var(--text-secondary); padding: 8px; background: var(--bg-tertiary); border-radius: 4px;">
                                    Selecciona un color origen con el cuentagotas
                                </div>
                            </div>
                            
                            <div class="control-group" id="colorStatsPanel" style="margin-top: 10px; display: none;">
                                <label class="control-label">üìà Estad√≠sticas en Tiempo Real</label>
                                <div style="font-size: 10px; color: var(--text-secondary); padding: 8px; background: var(--bg-tertiary); border-radius: 4px;">
                                    <div id="colorStatsContent">
                                        <div>üéØ P√≠xeles coincidentes: <span id="matchingPixels">0</span></div>
                                        <div>üìä Porcentaje de imagen: <span id="imagePercentage">0%</span></div>
                                        <div>üåà Colores √∫nicos: <span id="uniqueColors">0</span></div>
                                        <div>üíæ Tama√±o de √°rea: <span id="areaSize">0 px¬≤</span></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="control-group" id="arrowProperties" style="display: none;">
                            <label class="control-label">‚û°Ô∏è Tipo de Flecha</label>
                            <select class="input" id="arrowType" onchange="updateArrowType(this.value)">
                                <option value="simple">Simple</option>
                                <option value="double">Doble</option>
                                <option value="curved">Curva</option>
                                <option value="thick">Gruesa</option>
                                <option value="dashed">Punteada</option>
                                <option value="outline">Contorno</option>
                            </select>
                            
                            <label class="control-label">üìè Grosor de L√≠nea</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="arrowThickness" min="1" max="20" value="3" oninput="updateArrowThickness(this.value)">
                                <span class="slider-value" id="arrowThicknessValue">3</span>
                            </div>
                            
                            <label class="control-label">üî∫ Tama√±o de Punta</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="arrowHeadSize" min="5" max="50" value="15" oninput="updateArrowHeadSize(this.value)">
                                <span class="slider-value" id="arrowHeadSizeValue">15</span>
                            </div>
                            
                            <label class="control-label">üé® Paleta de Colores</label>
                            <div class="color-palette" id="colorPalette">
                                <div class="color-swatch" data-color="#FF0000" style="background-color: #FF0000;"></div>
                                <div class="color-swatch" data-color="#00FF00" style="background-color: #00FF00;"></div>
                                <div class="color-swatch" data-color="#0000FF" style="background-color: #0000FF;"></div>
                                <div class="color-swatch" data-color="#FFFF00" style="background-color: #FFFF00;"></div>
                                <div class="color-swatch" data-color="#FF00FF" style="background-color: #FF00FF;"></div>
                                <div class="color-swatch" data-color="#00FFFF" style="background-color: #00FFFF;"></div>
                                <div class="color-swatch" data-color="#FFA500" style="background-color: #FFA500;"></div>
                                <div class="color-swatch" data-color="#800080" style="background-color: #800080;"></div>
                                <div class="color-swatch" data-color="#000000" style="background-color: #000000;"></div>
                                <div class="color-swatch" data-color="#FFFFFF" style="background-color: #FFFFFF; border: 1px solid #ccc;"></div>
                            </div>
                            
                            <label class="control-label">üåà Color Personalizado</label>
                            <div class="color-picker">
                                <input type="color" id="arrowColor" value="#FF0000" onchange="updateArrowColor(this.value)">
                            </div>
                            
                            <label class="control-label">Opacidad</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="arrowOpacity" min="10" max="100" value="100" oninput="updateArrowOpacity(this.value)">
                                <span class="slider-value" id="arrowOpacityValue">100</span>
                            </div>
                        </div>

                        <div class="control-group" id="textProperties" style="display: none;">
                            <label class="control-label">Tipo de Fuente</label>
                                                <select class="input" id="textFont" onchange="updateTextFont(this.value)">
                            <option value="Arial">üìù Arial</option>
                            <option value="Helvetica">üìù Helvetica</option>
                            <option value="Times New Roman">üì∞ Times New Roman</option>
                            <option value="Georgia">üìö Georgia</option>
                            <option value="Courier New">üíª Courier New</option>
                            <option value="Verdana">üìÑ Verdana</option>
                            <option value="Impact">üí• Impact</option>
                            <option value="Comic Sans MS">üé® Comic Sans MS</option>
                            <option value="Trebuchet MS">‚ö° Trebuchet MS</option>
                            <option value="Tahoma">üì± Tahoma</option>
                            <option value="PT Sans Narrow">üìê PT Sans Narrow</option>
                            <option value="Brush Script MT">üñåÔ∏è Brush Script MT</option>
                            <option value="Lucida Handwriting">‚úçÔ∏è Lucida Handwriting</option>
                            <option value="Chiller">üßä Chiller</option>
                            <option value="Papyrus">üìú Papyrus</option>
                            <option value="Stencil">üî§ Stencil</option>
                            <option value="Wide Latin">üèõÔ∏è Wide Latin</option>
                            <option value="Old English Text MT">üëë Old English</option>
                            <option value="Ravie">üåä Ravie</option>
                            <option value="Showcard Gothic">üé≠ Showcard Gothic</option>
                            <option value="Bauhaus 93">üèóÔ∏è Bauhaus 93</option>
                        </select>
                            
                            <label class="control-label">Tama√±o de Fuente</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="textSize" min="8" max="120" value="24" oninput="updateTextSize(this.value)">
                                <span class="slider-value" id="textSizeValue">24px</span>
                            </div>
                            
                            <label class="control-label">Estilo</label>
                            <div class="input-group">
                                <button class="btn text-style-btn" id="textBold" onclick="toggleTextStyle('bold')">B</button>
                                <button class="btn text-style-btn" id="textItalic" onclick="toggleTextStyle('italic')">I</button>
                                <button class="btn text-style-btn" id="textUnderline" onclick="toggleTextStyle('underline')">U</button>
                            </div>
                            
                            <label class="control-label">Alineaci√≥n</label>
                            <div class="input-group">
                                <button class="btn text-align-btn" onclick="updateTextAlign('left')">‚¨ÖÔ∏è</button>
                                <button class="btn text-align-btn" onclick="updateTextAlign('center')">‚¨ÜÔ∏è</button>
                                <button class="btn text-align-btn" onclick="updateTextAlign('right')">‚û°Ô∏è</button>
                            </div>
                            
                            <label class="control-label">Color de Texto</label>
                            <div class="color-picker">
                                <input type="color" id="textColorPicker" value="#FF0000" onchange="updateTextColor(this.value)">
                            </div>
                            
                            <button class="btn primary" onclick="addTextToCanvas()">üìù A√±adir Texto</button>
                        </div>

                        <div class="control-group" id="shapeProperties" style="display: none;">
                            <label class="control-label">Tipo de Forma</label>
                            <select class="input" id="shapeType" onchange="updateShapeType(this.value)">
                                <optgroup label="üîµ Formas B√°sicas">
                                    <option value="circle">‚ö™ C√≠rculo</option>
                                    <option value="square">‚¨ú Cuadrado</option>
                                    <option value="rectangle">‚ñ¨ Rect√°ngulo</option>
                                    <option value="ellipse">ü•ö Elipse</option>
                                </optgroup>
                                <optgroup label="üìè L√≠neas">
                                    <option value="line">‚îÅ L√≠nea Recta</option>
                                    <option value="diagonal">‚ï± L√≠nea Diagonal</option>
                                </optgroup>
                                <optgroup label="üî∫ Pol√≠gonos">
                                    <option value="triangle">üî∫ Tri√°ngulo</option>
                                    <option value="pentagon">‚¨ü Pent√°gono</option>
                                    <option value="hexagon">‚¨° Hex√°gono</option>
                                    <option value="octagon">‚¨¢ Oct√°gono</option>
                                </optgroup>
                                <optgroup label="‚ú® Formas Especiales">
                                    <option value="star">‚≠ê Estrella</option>
                                    <option value="diamond">üíé Rombo</option>
                                    <option value="trapezoid">üîπ Trapecio</option>
                                    <option value="parallelogram">‚ñ∞ Paralelogramo</option>
                                </optgroup>
                                <optgroup label="üéØ S√≠mbolos">
                                    <option value="heart">‚ù§Ô∏è Coraz√≥n</option>
                                    <option value="cross">‚ûï Cruz</option>
                                    <option value="cloud">‚òÅÔ∏è Nube</option>
                                    <option value="lightning">‚ö° Rayo</option>
                                </optgroup>
                                <optgroup label="üîÆ Formas Avanzadas">
                                    <option value="spiral">üåÄ Espiral</option>
                                    <option value="arc">üåô Arco</option>
                                    <option value="sector">üç∞ Sector Circular</option>
                                    <option value="gear">‚öôÔ∏è Engranaje</option>
                                </optgroup>
                            </select>
                            
                            <label class="control-label">Estilo de Relleno</label>
                            <select class="input" id="shapeStyle" onchange="updateShapeStyle(this.value)">
                                <option value="fill">üé® Relleno</option>
                                <option value="stroke">‚≠ï Solo Contorno</option>
                                <option value="both">üîò Contorno y Relleno</option>
                            </select>
                            
                            <label class="control-label">Grosor de Contorno</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="shapeStrokeWidth" min="1" max="20" value="3" oninput="updateShapeStrokeWidth(this.value)">
                                <span class="slider-value" id="shapeStrokeWidthValue">3</span>
                            </div>
                            
                            <label class="control-label">Color de Relleno</label>
                            <div class="color-picker">
                                <input type="color" id="shapeFillColor" value="#FF0000" onchange="updateShapeFillColor(this.value)">
                            </div>
                            
                            <label class="control-label">Color de Contorno</label>
                            <div class="color-picker">
                                <input type="color" id="shapeStrokeColor" value="#000000" onchange="updateShapeStrokeColor(this.value)">
                            </div>
                            
                            <label class="control-label">Opacidad</label>
                            <div class="slider-container">
                                <input type="range" class="slider" id="shapeOpacity" min="10" max="100" value="100" oninput="updateShapeOpacity(this.value)">
                                <span class="slider-value" id="shapeOpacityValue">100%</span>
                            </div>
                            
                            <div id="shapeSpecialControls">
                                <!-- Controles espec√≠ficos para formas especiales -->
                                <div id="starControls" style="display: none;">
                                    <label class="control-label">N√∫mero de Puntas</label>
                                    <div class="slider-container">
                                        <input type="range" class="slider" id="starSpikes" min="3" max="20" value="5" oninput="updateStarSpikes(this.value)">
                                        <span class="slider-value" id="starSpikesValue">5</span>
                                    </div>
                                    
                                    <label class="control-label">Profundidad</label>
                                    <div class="slider-container">
                                        <input type="range" class="slider" id="starDepth" min="0.1" max="0.9" step="0.1" value="0.5" oninput="updateStarDepth(this.value)">
                                        <span class="slider-value" id="starDepthValue">0.5</span>
                                    </div>
                                </div>
                                
                                <div id="spiralControls" style="display: none;">
                                    <label class="control-label">N√∫mero de Vueltas</label>
                                    <div class="slider-container">
                                        <input type="range" class="slider" id="spiralTurns" min="1" max="10" value="3" oninput="updateSpiralTurns(this.value)">
                                        <span class="slider-value" id="spiralTurnsValue">3</span>
                                    </div>
                                </div>
                                
                                <div id="arcControls" style="display: none;">
                                    <label class="control-label">√Ångulo de Inicio</label>
                                    <div class="slider-container">
                                        <input type="range" class="slider" id="arcStartAngle" min="0" max="360" value="0" oninput="updateArcStartAngle(this.value)">
                                        <span class="slider-value" id="arcStartAngleValue">0¬∞</span>
                                    </div>
                                    
                                    <label class="control-label">√Ångulo de Fin</label>
                                    <div class="slider-container">
                                        <input type="range" class="slider" id="arcEndAngle" min="0" max="360" value="180" oninput="updateArcEndAngle(this.value)">
                                        <span class="slider-value" id="arcEndAngleValue">180¬∞</span>
                                    </div>
                                </div>
                                
                                <div id="gearControls" style="display: none;">
                                    <label class="control-label">N√∫mero de Dientes</label>
                                    <div class="slider-container">
                                        <input type="range" class="slider" id="gearTeeth" min="6" max="20" value="8" oninput="updateGearTeeth(this.value)">
                                        <span class="slider-value" id="gearTeethValue">8</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Histogram -->
                <div class="panel-section">
                    <div class="panel-title" onclick="togglePanel(this)">
                        <span>Histograma</span>
                        <button class="panel-toggle-btn">‚ñº</button>
                    </div>
                    <div class="panel-content">
                        <div class="histogram-container">
                            <canvas id="histogramCanvas"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Layers -->
                <div class="panel-section">
                    <div class="panel-title" onclick="togglePanel(this)">
                        <span>Capas</span>
                        <button class="panel-toggle-btn">‚ñº</button>
                    </div>
                    <div class="panel-content">
                        <div class="layers-list" id="layersList">
                            <div class="layer-item active">
                                <div class="layer-thumb"></div>
                                <span>Fondo</span>
                            </div>
                        </div>
                        <div style="margin-top: 8px;">
                            <button class="btn" onclick="addLayer()">+ Nueva Capa</button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Status Bar -->
        <div class="status-bar">
            <span id="filePathInfo">üìÅ Sin imagen</span>
            <span class="status-separator">|</span>
            <span id="imageDimensions">üìê - √ó - p√≠xeles</span>
            <span class="status-separator">|</span>
            <span id="fileSizeInfo">üì¶ -</span>
            <span class="status-separator">|</span>
            <span id="zoomLevel">üîç 100%</span>
            <span class="status-separator">|</span>
            <span id="currentTool">üîß Seleccionar</span>
            <span class="status-separator">|</span>
            <span id="mousePos">üñ±Ô∏è x: 0, y: 0</span>
            <span class="status-separator">|</span>
            <span id="pixelInfo">üé® RGB: -, -, -</span>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">‚öôÔ∏è Ajustes de Aplicaci√≥n</div>
            
            <!-- Canvas Settings -->
            <div class="help-section">
                <h3>üñºÔ∏è Configuraci√≥n del Lienzo</h3>
                
                <div class="control-group">
                    <label class="control-label">Tama√±o Predeterminado</label>
                    <select class="input" id="defaultCanvasSize" onchange="updateCanvasSizePreview()">
                        <option value="fullscreen">üì∫ Pantalla Completa</option>
                        <option value="hd">üìπ HD (1920x1080)</option>
                        <option value="4k">üé¨ 4K (3840x2160)</option>
                        <option value="square-lg">‚¨ú Cuadrado Grande (1080x1080)</option>
                        <option value="square-md">‚¨ú Cuadrado Mediano (800x800)</option>
                        <option value="a4">üìÑ A4 (210x297mm)</option>
                        <option value="custom">üîß Personalizado</option>
                    </select>
                </div>
                
                <div class="control-group" id="customSizeControls" style="display: none;">
                    <label class="control-label">Tama√±o Personalizado</label>
                    <div class="input-group">
                        <input type="number" class="input" id="customWidth" placeholder="Ancho" min="100" max="4000" value="1920" oninput="updateCanvasSizePreview()">
                        <span style="padding: 4px 8px;">√ó</span>
                        <input type="number" class="input" id="customHeight" placeholder="Alto" min="100" max="4000" value="1080" oninput="updateCanvasSizePreview()">
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Color de Fondo Predeterminado</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="color-picker">
                            <input type="color" id="defaultBackgroundColor" value="#FFFFFF">
                        </div>
                        <button class="btn" onclick="setBackgroundColor('#FFFFFF')">‚¨ú Blanco</button>
                        <button class="btn" onclick="setBackgroundColor('#000000')">‚¨õ Negro</button>
                        <button class="btn" onclick="setBackgroundColor('transparent')">üî≥ Transparente</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <div id="canvasSizePreview" style="padding: 10px; background: var(--bg-tertiary); border-radius: 4px; text-align: center; font-size: 12px; color: var(--text-secondary);">
                        Vista previa: 1920 √ó 1080 p√≠xeles
                    </div>
                </div>
            </div>

            <!-- Tool Settings -->
            <div class="help-section">
                <h3>üõ†Ô∏è Herramientas Predeterminadas</h3>
                
                <div class="control-group">
                    <label class="control-label">Herramienta Inicial</label>
                    <select class="input" id="defaultTool">
                        <option value="select">üîΩ Seleccionar</option>
                        <option value="brush">üñåÔ∏è Pincel</option>
                        <option value="text">üìù Texto</option>
                        <option value="shapes">üü¢ Formas</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Color Predeterminado</label>
                    <div class="color-picker">
                        <input type="color" id="defaultToolColor" value="#FF0000">
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Grosor Predeterminado</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="defaultThickness" min="1" max="50" value="5" oninput="updateSliderUI('defaultThickness', this.value)">
                        <span class="slider-value" id="defaultThicknessValue">5px</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Tama√±o de Fuente Predeterminado</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="defaultFontSize" min="8" max="120" value="24" oninput="updateSliderUI('defaultFontSize', this.value)">
                        <span class="slider-value" id="defaultFontSizeValue">24px</span>
                    </div>
                </div>
            </div>

            <!-- Performance Settings -->
            <div class="help-section">
                <h3>‚ö° Rendimiento</h3>
                
                <div class="control-group">
                    <label class="control-label">Calidad de Renderizado</label>
                    <select class="input" id="renderQuality">
                        <option value="high">üî• Alta (Mejor calidad)</option>
                        <option value="medium">‚ö° Media (Equilibrada)</option>
                        <option value="low">üí® Baja (M√°s r√°pida)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label class="control-label">L√≠mite de Historial</label>
                    <select class="input" id="historyLimit">
                        <option value="20">20 acciones</option>
                        <option value="30" selected>30 acciones</option>
                        <option value="50">50 acciones</option>
                        <option value="100">100 acciones</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Autoguardado</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="checkbox" id="autoSave" checked>
                        <label for="autoSave">Guardar configuraci√≥n autom√°ticamente</label>
                    </div>
                </div>
            </div>

            <!-- UI Settings -->
            <div class="help-section">
                <h3>üé® Interfaz</h3>
                
                <div class="control-group">
                    <label class="control-label">Tema Predeterminado</label>
                    <select class="input" id="defaultTheme">
                        <option value="dark">üåô Oscuro</option>
                        <option value="light">‚òÄÔ∏è Claro</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Mostrar Tooltips</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="checkbox" id="showTooltips" checked>
                        <label for="showTooltips">Mostrar ayudas al pasar el rat√≥n</label>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Animaciones</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="checkbox" id="enableAnimations" checked>
                        <label for="enableAnimations">Habilitar animaciones de interfaz</label>
                    </div>
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="btn" onclick="resetToDefaults()">üîÑ Restaurar Valores por Defecto</button>
                <button class="btn" onclick="closeModal('settingsModal')">‚ùå Cancelar</button>
                <button class="btn primary" onclick="saveSettings()">‚úÖ Guardar Ajustes</button>
            </div>
        </div>
    </div>

            <!-- Export Modal -->
        <div class="modal" id="exportModal">
            <div class="modal-content">
                <div class="modal-header">üì§ Guardar como</div>
                
            <div class="control-group">
                <label class="control-label">üìÑ Nombre del archivo</label>
                <input type="text" class="input" id="exportFileName" placeholder="mi_imagen" maxlength="100">
                <small style="color: #888; font-size: 11px;">Solo el nombre, sin extensi√≥n</small>
            </div>
            
            <div class="control-group">
                <label class="control-label">üìÅ Directorio</label>
                <div id="modernApiInfo" style="background: var(--bg-tertiary); padding: 8px; border-radius: 4px; border: 1px solid var(--border); display: none;">
                    <div style="color: var(--text-primary); font-size: 12px;">üöÄ Selector de directorio moderno disponible</div>
                    <small style="color: #4CAF50; font-size: 10px;">‚úÖ Puede elegir d√≥nde guardar el archivo</small>
                    <br>
                    <small style="color: #666; font-size: 9px;">üí° Su navegador soporta la API moderna de archivos</small>
                </div>
                <div id="fallbackInfo" style="background: var(--bg-tertiary); padding: 8px; border-radius: 4px; border: 1px solid var(--border);">
                    <div style="color: var(--text-primary); font-size: 12px;">üìÇ Carpeta de Descargas del navegador</div>
                    <small style="color: #888; font-size: 10px;">‚ö†Ô∏è Los navegadores web no permiten elegir directorios espec√≠ficos por seguridad</small>
                    <br>
                    <small style="color: #666; font-size: 9px;">üí° Despu√©s de descargar, puedes mover el archivo desde Descargas a donde necesites</small>
                </div>
            </div>
                
            <div class="control-group">
                <label class="control-label">Formato</label>
                <select class="input" id="exportFormat">
                    <option value="png">PNG</option>
                    <option value="jpeg">JPEG</option>
                    <option value="webp">WebP</option>
                </select>
            </div>
            <div class="control-group" id="qualityControl">
                <label class="control-label">Calidad</label>
                <div class="slider-container">
                    <input type="range" class="slider" id="exportQuality" min="0.1" max="1" step="0.1" value="0.9">
                    <span class="slider-value" id="exportQualityValue">90%</span>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Tama√±o</label>
                <select class="input" id="exportSize">
                    <option value="original">Original</option>
                    <option value="hd">HD (1920x1080)</option>
                    <option value="social">Redes Sociales (1080x1080)</option>
                    <option value="web">Web (800x600)</option>
                    <option value="custom">Personalizado</option>
                </select>
            </div>
            <div class="modal-actions">
                <button class="btn" onclick="closeModal('exportModal')">‚ùå Cancelar</button>
                <button class="btn primary" onclick="performExport()">üíæ Guardar</button>
            </div>
        </div>
    </div>

    <!-- Color Palette Panel -->
    <div class="floating-panel" id="colorPalettePanel">
        <h3>üé® Paleta de Colores</h3>
        <div class="quick-color-grid">
            <div class="quick-color-swatch" data-color="#FF0000" style="background-color: #FF0000;" title="Rojo"></div>
            <div class="quick-color-swatch" data-color="#00FF00" style="background-color: #00FF00;" title="Verde"></div>
            <div class="quick-color-swatch" data-color="#0000FF" style="background-color: #0000FF;" title="Azul"></div>
            <div class="quick-color-swatch" data-color="#FFFF00" style="background-color: #FFFF00;" title="Amarillo"></div>
            <div class="quick-color-swatch" data-color="#FF00FF" style="background-color: #FF00FF;" title="Magenta"></div>
            <div class="quick-color-swatch" data-color="#00FFFF" style="background-color: #00FFFF;" title="Cian"></div>
            <div class="quick-color-swatch" data-color="#FFA500" style="background-color: #FFA500;" title="Naranja"></div>
            <div class="quick-color-swatch" data-color="#800080" style="background-color: #800080;" title="P√∫rpura"></div>
            <div class="quick-color-swatch" data-color="#000000" style="background-color: #000000;" title="Negro"></div>
            <div class="quick-color-swatch" data-color="#FFFFFF" style="background-color: #FFFFFF; border: 1px solid #ccc;" title="Blanco"></div>
            <div class="quick-color-swatch" data-color="#8B4513" style="background-color: #8B4513;" title="Marr√≥n"></div>
            <div class="quick-color-swatch" data-color="#FFC0CB" style="background-color: #FFC0CB;" title="Rosa"></div>
        </div>
        <div class="control-group">
            <label class="control-label">Color Personalizado</label>
            <input type="color" class="input" id="quickColorPicker" value="#FF0000" onchange="selectQuickColor(this.value)">
        </div>
    </div>

    <!-- Thickness Panel -->
    <div class="floating-panel" id="thicknessPanel">
        <h3>üìè Grosor de L√≠nea</h3>
        <div class="thickness-options">
            <div class="thickness-option" data-size="1" onclick="selectThickness(1)">
                <div class="thickness-preview" data-size="1"></div>
                <span>Muy Fino (1px)</span>
            </div>
            <div class="thickness-option" data-size="3" onclick="selectThickness(3)">
                <div class="thickness-preview" data-size="3"></div>
                <span>Fino (3px)</span>
            </div>
            <div class="thickness-option active" data-size="5" onclick="selectThickness(5)">
                <div class="thickness-preview" data-size="5"></div>
                <span>Normal (5px)</span>
            </div>
            <div class="thickness-option" data-size="8" onclick="selectThickness(8)">
                <div class="thickness-preview" data-size="8"></div>
                <span>Grueso (8px)</span>
            </div>
            <div class="thickness-option" data-size="12" onclick="selectThickness(12)">
                <div class="thickness-preview" data-size="12"></div>
                <span>Muy Grueso (12px)</span>
            </div>
            <div class="thickness-option" data-size="20" onclick="selectThickness(20)">
                <div class="thickness-preview" data-size="20"></div>
                <span>Extra Grueso (20px)</span>
            </div>
        </div>
        <div class="control-group" style="margin-top: 12px;">
            <label class="control-label">Grosor Personalizado</label>
            <div class="slider-container">
                <input type="range" class="slider" id="customThickness" min="1" max="50" value="5" oninput="selectThickness(this.value, true)">
                <span class="slider-value" id="customThicknessValue">5px</span>
            </div>
        </div>
    </div>

    <!-- Shapes Control Panel -->
    <div class="floating-panel" id="shapesPanel" style="width: 320px; max-height: 500px; overflow-y: auto;">
        <h3>üü¢ Formas Geom√©tricas</h3>
        
        <div class="control-group">
            <label class="control-label">Tipo de Forma</label>
            <select class="input" id="floatingShapeType" onchange="updateFloatingShapeType(this.value)">
                <optgroup label="üîµ Formas B√°sicas">
                    <option value="circle">‚ö™ C√≠rculo</option>
                    <option value="square">‚¨ú Cuadrado</option>
                    <option value="rectangle">‚ñ¨ Rect√°ngulo</option>
                    <option value="ellipse">ü•ö Elipse</option>
                </optgroup>
                <optgroup label="üìè L√≠neas">
                    <option value="line">‚îÅ L√≠nea Recta</option>
                    <option value="diagonal">‚ï± L√≠nea Diagonal</option>
                </optgroup>
                <optgroup label="üî∫ Pol√≠gonos">
                    <option value="triangle">üî∫ Tri√°ngulo</option>
                    <option value="pentagon">‚¨ü Pent√°gono</option>
                    <option value="hexagon">‚¨° Hex√°gono</option>
                    <option value="octagon">‚¨¢ Oct√°gono</option>
                </optgroup>
                <optgroup label="‚ú® Formas Especiales">
                    <option value="star">‚≠ê Estrella</option>
                    <option value="diamond">üíé Rombo</option>
                    <option value="trapezoid">üîπ Trapecio</option>
                    <option value="parallelogram">‚ñ∞ Paralelogramo</option>
                </optgroup>
                <optgroup label="üéØ S√≠mbolos">
                    <option value="heart">‚ù§Ô∏è Coraz√≥n</option>
                    <option value="cross">‚ûï Cruz</option>
                    <option value="cloud">‚òÅÔ∏è Nube</option>
                    <option value="lightning">‚ö° Rayo</option>
                </optgroup>
                <optgroup label="üîÆ Formas Avanzadas">
                    <option value="spiral">üåÄ Espiral</option>
                    <option value="arc">üåô Arco</option>
                    <option value="sector">üç∞ Sector Circular</option>
                    <option value="gear">‚öôÔ∏è Engranaje</option>
                </optgroup>
            </select>
        </div>
        
        <div class="control-group">
            <label class="control-label">Estilo de Relleno</label>
            <select class="input" id="floatingShapeStyle" onchange="updateFloatingShapeStyle(this.value)">
                <option value="fill">üé® Relleno</option>
                <option value="stroke">‚≠ï Solo Contorno</option>
                <option value="both">üîò Contorno y Relleno</option>
            </select>
        </div>
        
        <div class="control-group">
            <label class="control-label">Grosor de Contorno</label>
            <div class="slider-container">
                <input type="range" class="slider" id="floatingShapeStrokeWidth" min="1" max="20" value="3" oninput="updateFloatingShapeStrokeWidth(this.value)">
                <span class="slider-value" id="floatingShapeStrokeWidthValue">3</span>
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Color de Relleno</label>
            <div class="color-picker">
                <input type="color" id="floatingShapeFillColor" value="#FF0000" onchange="updateFloatingShapeFillColor(this.value)">
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Color de Contorno</label>
            <div class="color-picker">
                <input type="color" id="floatingShapeStrokeColor" value="#000000" onchange="updateFloatingShapeStrokeColor(this.value)">
            </div>
        </div>
        
        <div class="control-group">
            <label class="control-label">Opacidad</label>
            <div class="slider-container">
                <input type="range" class="slider" id="floatingShapeOpacity" min="10" max="100" value="100" oninput="updateFloatingShapeOpacity(this.value)">
                <span class="slider-value" id="floatingShapeOpacityValue">100%</span>
            </div>
        </div>
        
        <div id="floatingShapeSpecialControls">
            <!-- Controles espec√≠ficos para formas especiales -->
            <div id="floatingStarControls" style="display: none;">
                <div class="control-group">
                    <label class="control-label">N√∫mero de Puntas</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="floatingStarSpikes" min="3" max="20" value="5" oninput="updateFloatingStarSpikes(this.value)">
                        <span class="slider-value" id="floatingStarSpikesValue">5</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Profundidad</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="floatingStarDepth" min="0.1" max="0.9" step="0.1" value="0.5" oninput="updateFloatingStarDepth(this.value)">
                        <span class="slider-value" id="floatingStarDepthValue">0.5</span>
                    </div>
                </div>
            </div>
            
            <div id="floatingSpiralControls" style="display: none;">
                <div class="control-group">
                    <label class="control-label">N√∫mero de Vueltas</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="floatingSpiralTurns" min="1" max="10" value="3" oninput="updateFloatingSpiralTurns(this.value)">
                        <span class="slider-value" id="floatingSpiralTurnsValue">3</span>
                    </div>
                </div>
            </div>
            
            <div id="floatingArcControls" style="display: none;">
                <div class="control-group">
                    <label class="control-label">√Ångulo de Inicio</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="floatingArcStartAngle" min="0" max="360" value="0" oninput="updateFloatingArcStartAngle(this.value)">
                        <span class="slider-value" id="floatingArcStartAngleValue">0¬∞</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">√Ångulo de Fin</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="floatingArcEndAngle" min="0" max="360" value="90" oninput="updateFloatingArcEndAngle(this.value)">
                        <span class="slider-value" id="floatingArcEndAngleValue">90¬∞</span>
                    </div>
                </div>
            </div>
            
            <div id="floatingGearControls" style="display: none;">
                <div class="control-group">
                    <label class="control-label">N√∫mero de Dientes</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="floatingGearTeeth" min="6" max="20" value="8" oninput="updateFloatingGearTeeth(this.value)">
                        <span class="slider-value" id="floatingGearTeethValue">8</span>
                    </div>
                </div>
            </div>
        </div>
        

    </div>



    <!-- Text Input Modal -->
    <div class="modal" id="textModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">üìù Configurar y A√±adir Texto</div>
            
            <!-- Text Content -->
            <div class="control-group">
                <label class="control-label">Introduce tu texto:</label>
                <textarea class="input" id="textInput" placeholder="Escribe aqu√≠ tu texto... (Ctrl+Enter para a√±adir)" 
                         style="width: 100%; height: 100px; resize: vertical; font-family: var(--font-mono, monospace);" 
                         oninput="updateTextPreview()" onkeyup="updateTextPreview()" 
                         onkeydown="if(event.ctrlKey && event.key === 'Enter') { event.preventDefault(); confirmAddText(); }"></textarea>
            </div>
            
            <!-- Text Formatting Options -->
            <div style="display: flex; gap: 20px; margin: 16px 0;">
                <!-- Font and Size -->
                <div style="flex: 1;">
                    <label class="control-label">üìù Tipo de Fuente</label>
                    <select class="input" id="textFontModal" onchange="updateTextFont(this.value); updateTextPreview();">
                        <option value="Arial">üìù Arial</option>
                        <option value="Helvetica">üìù Helvetica</option>
                        <option value="Times New Roman">üì∞ Times New Roman</option>
                        <option value="Georgia">üìö Georgia</option>
                        <option value="Courier New">üíª Courier New</option>
                        <option value="Verdana">üìÑ Verdana</option>
                        <option value="Impact">üí• Impact</option>
                        <option value="Comic Sans MS">üé® Comic Sans MS</option>
                        <option value="Trebuchet MS">‚ö° Trebuchet MS</option>
                        <option value="Tahoma">üì± Tahoma</option>
                        <option value="PT Sans Narrow">üìê PT Sans Narrow</option>
                        <option value="Brush Script MT">üñåÔ∏è Brush Script MT</option>
                        <option value="Lucida Handwriting">‚úçÔ∏è Lucida Handwriting</option>
                        <option value="Chiller">üßä Chiller</option>
                        <option value="Papyrus">üìú Papyrus</option>
                        <option value="Stencil">üî§ Stencil</option>
                        <option value="Wide Latin">üèõÔ∏è Wide Latin</option>
                        <option value="Old English Text MT">üëë Old English</option>
                        <option value="Ravie">üåä Ravie</option>
                        <option value="Showcard Gothic">üé≠ Showcard Gothic</option>
                        <option value="Bauhaus 93">üèóÔ∏è Bauhaus 93</option>
                    </select>
                </div>
                
                <div style="flex: 1;">
                    <label class="control-label">üìê Tama√±o: <span id="textSizeModalValue">24px</span></label>
                    <input type="range" class="slider" id="textSizeModal" min="8" max="120" value="24" 
                           oninput="updateTextSize(this.value); updateTextPreview();" style="width: 100%;">
                </div>
            </div>
            
            <!-- Style and Alignment -->
            <div style="display: flex; gap: 20px; margin: 16px 0;">
                <div style="flex: 1;">
                    <label class="control-label">‚úèÔ∏è Estilo</label>
                    <div class="input-group">
                        <button class="btn text-style-btn" id="textBoldModal" onclick="toggleTextStyle('bold'); updateTextPreview();">B</button>
                        <button class="btn text-style-btn" id="textItalicModal" onclick="toggleTextStyle('italic'); updateTextPreview();">I</button>
                        <button class="btn text-style-btn" id="textUnderlineModal" onclick="toggleTextStyle('underline'); updateTextPreview();">U</button>
                    </div>
                </div>
                
                <div style="flex: 1;">
                    <label class="control-label">üìê Alineaci√≥n</label>
                    <div class="input-group">
                        <button class="btn text-align-btn" onclick="updateTextAlign('left'); updateTextPreview();">‚¨ÖÔ∏è Izq</button>
                        <button class="btn text-align-btn" onclick="updateTextAlign('center'); updateTextPreview();">‚¨ÜÔ∏è Centro</button>
                        <button class="btn text-align-btn" onclick="updateTextAlign('right'); updateTextPreview();">‚û°Ô∏è Der</button>
                    </div>
                </div>
            </div>
            
            <!-- Color -->
            <div class="control-group">
                <label class="control-label">üé® Color de Texto</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <div class="color-picker">
                        <input type="color" id="textColorPickerModal" value="#FF0000" onchange="updateTextColor(this.value); updateTextPreview();">
                    </div>
                    <span style="font-size: 12px; color: var(--text-secondary);">O usa la paleta flotante (tecla P)</span>
                </div>
            </div>
            
            <!-- Preview -->
            <div class="control-group">
                <label class="control-label">üëÄ Vista previa:</label>
                <div id="textPreview" style="padding: 15px; border: 2px solid var(--border); border-radius: 6px; background: var(--bg-tertiary); min-height: 60px; overflow-wrap: break-word;">
                    Vista previa del texto aparecer√° aqu√≠...
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="btn" onclick="closeTextModal()">‚ùå Cancelar</button>
                <button class="btn primary" onclick="confirmAddText()">‚úÖ A√±adir Texto</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal" id="helpModal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh;">
            <div class="modal-header">‚ùì Gu√≠a Completa del Editor de Im√°genes Profesional v2.0</div>
            
            <div style="overflow-y: auto; max-height: 70vh; padding-right: 10px;">
                <!-- Introducci√≥n -->
                <div class="help-section">
                    <h3>üåü Bienvenido al Editor Profesional</h3>
                    <p>Un editor de im√°genes completo con herramientas avanzadas de edici√≥n, texto editable, flechas personalizables y mucho m√°s.</p>
                </div>

                <!-- Atajos de Teclado -->
                <div class="help-section">
                    <h3>‚å®Ô∏è Atajos de Teclado</h3>
                    <div class="help-grid">
                        <div class="help-item">
                            <strong>Herramientas:</strong><br>
                            V - Seleccionar | C - Recortar | B - Pincel | E - Borrador<br>
                            T - Texto | U - Formas | A - Flechas | G - Degradado | D - Cuentagotas | Z - Zoom<br>
                            P - Paleta de Colores | R - Control de Grosor
                        </div>
                        <div class="help-item">
                            <strong>Acciones:</strong><br>
                            Ctrl+Z - Deshacer | Ctrl+Y - Rehacer<br>
                            Ctrl+O - Abrir | Ctrl+S - Guardar<br>
                            Ctrl+A - Seleccionar todo | Ctrl+D - Deseleccionar<br>
                            Ctrl+L - Auto-mejora | ESC - Cancelar/Cerrar
                        </div>
                    </div>
                </div>

                <!-- Cargar Im√°genes -->
                <div class="help-section">
                    <h3>üìÅ Cargar Im√°genes</h3>
                    <ul>
                        <li><strong>Bot√≥n "üìÅ Abrir":</strong> Selecciona archivos desde tu ordenador</li>
                        <li><strong>Arrastrar y Soltar:</strong> Arrastra im√°genes directamente al √°rea central</li>
                        <li><strong>Ctrl+V:</strong> Pega im√°genes desde el portapapeles</li>
                        <li><strong>Formatos soportados:</strong> JPG, PNG, GIF, WebP, BMP, TIFF</li>
                        <li><strong>Ajuste autom√°tico:</strong> Las im√°genes se redimensionan para ajustarse a la ventana</li>
                    </ul>
                </div>

                <!-- Herramientas B√°sicas -->
                <div class="help-section">
                    <h3>üõ†Ô∏è Herramientas B√°sicas</h3>
                    <div class="help-grid">
                        <div class="help-item">
                            <strong>üîΩ Seleccionar (V):</strong><br>
                            Selecciona √°reas de la imagen para recortar o mover elementos
                        </div>
                        <div class="help-item">
                            <strong>‚úÇÔ∏è Recortar (C):</strong><br>
                            Selecciona un √°rea rectangular - Se recorta autom√°ticamente al soltar
                        </div>
                        <div class="help-item">
                            <strong>üñåÔ∏è Pincel (B):</strong><br>
                            Dibuja y pinta con grosor y color personalizables
                        </div>
                        <div class="help-item">
                            <strong>üßΩ Borrador (E):</strong><br>
                            Borra partes de la imagen con grosor ajustable
                        </div>
                        <div class="help-item">
                            <strong>üîç Zoom (Z):</strong><br>
                            CTRL+Rueda = Zoom preciso en la zona del cursor | Rueda = Scroll cuando hay zoom
                        </div>
                        <div class="help-item">
                            <strong>üü¢ Formas (U):</strong><br>
                            Panel flotante con 22 formas geom√©tricas diferentes
                        </div>
                        <div class="help-item">
                            <strong>üåà Gradientes (G):</strong><br>
                            Haz clic y arrastra para aplicar gradientes de color sobre la imagen
                        </div>
                        <div class="help-item">
                            <strong>üíß Cuentagotas (D):</strong><br>
                            Indicador flotante que muestra colores en tiempo real del canvas
                        </div>
                        <div class="help-item">
                            <strong>üë• Clonar (S):</strong><br>
                            Arrastra para seleccionar | Clic para pegar √°rea clonada
                        </div>
                    </div>
                </div>

                <!-- Sistema de Texto Avanzado -->
                <div class="help-section">
                    <h3>üìù Sistema de Texto S√∫per Avanzado</h3>
                    <div class="help-subsection">
                        <h4>‚ú® A√±adir Texto Nuevo:</h4>
                        <ol>
                            <li><strong>Selecciona la herramienta T</strong> (o presiona tecla T)</li>
                            <li><strong>Haz clic en la imagen</strong> donde quieras colocar el texto</li>
                            <li><strong>Se abre un modal completo</strong> con todas las opciones:
                                <ul>
                                    <li>üìù <strong>21 fuentes chulas:</strong> üìê PT Sans Narrow, üñåÔ∏è Brush Script, ‚úçÔ∏è Lucida Handwriting, üßä Chiller, üìú Papyrus, üëë Old English, üåä Ravie, etc.</li>
                                    <li>üìê <strong>Tama√±o:</strong> De 8px a 120px con control deslizante</li>
                                    <li>‚úèÔ∏è <strong>Estilos:</strong> Negrita, Cursiva, Subrayado (combinables)</li>
                                    <li>üìê <strong>Alineaci√≥n:</strong> Izquierda, Centro, Derecha</li>
                                    <li>üé® <strong>Color:</strong> Selector + acceso a paleta flotante</li>
                                    <li>üëÄ <strong>Vista previa en tiempo real</strong> de todos los cambios</li>
                                </ul>
                            </li>
                            <li><strong>Ctrl+Enter</strong> o bot√≥n "‚úÖ A√±adir Texto" para confirmar</li>
                        </ol>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>‚úèÔ∏è Editar Textos Existentes:</h4>
                        <ul>
                            <li><strong>Haz clic</strong> en cualquier texto ya colocado para seleccionarlo</li>
                            <li><strong>Aparecen handles de colores:</strong>
                                <ul>
                                    <li>üü¢ <strong>Verde (centro):</strong> Arrastra para MOVER el texto</li>
                                    <li>üü† <strong>Naranjas (esquinas):</strong> Arrastra para REDIMENSIONAR</li>
                                    <li>üîµ <strong>Azul (arriba-derecha):</strong> DOBLE CLIC para editar contenido</li>
                                </ul>
                            </li>
                            <li><strong>Panel derecho:</strong> Tambi√©n puedes usar los controles del panel "Propiedades de Herramienta"</li>
                            <li><strong>Multilinea:</strong> Usa Enter en el modal para crear l√≠neas m√∫ltiples</li>
                        </ul>
                    </div>
                </div>

                <!-- Sistema de Flechas -->
                <div class="help-section">
                    <h3>‚û°Ô∏è Flechas Personalizables</h3>
                    <ul>
                        <li><strong>Crear flecha:</strong> Selecciona herramienta A, haz clic y arrastra</li>
                        <li><strong>Tipos disponibles:</strong> Simple, Doble, Curva, Gruesa, Punteada, Contorno</li>
                        <li><strong>Editar existente:</strong> Haz clic en una flecha para mostrar sus handles</li>
                        <li><strong>Propiedades ajustables:</strong> Grosor, tama√±o de punta, color, opacidad</li>
                        <li><strong>Sistema unificado:</strong> Color y grosor se sincronizan con otras herramientas</li>
                    </ul>
                </div>

                <!-- Sistema de Gradientes -->
                <div class="help-section">
                    <h3>üåà Gradientes de Color</h3>
                    <div class="help-subsection">
                        <h4>‚ú® C√≥mo Aplicar Gradientes:</h4>
                        <ol>
                            <li><strong>Selecciona la herramienta G</strong> (o presiona tecla G)</li>
                            <li><strong>Elige tu color principal</strong> desde la paleta de colores</li>
                            <li><strong>Haz clic y arrastra</strong> en la imagen para definir la direcci√≥n del gradiente</li>
                            <li><strong>Suelta el mouse</strong> para aplicar el gradiente</li>
                        </ol>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>üé® Caracter√≠sticas del Gradiente:</h4>
                        <ul>
                            <li><strong>üéØ Direccional:</strong> La direcci√≥n del arrastre define la transici√≥n</li>
                            <li><strong>üåà Dos colores:</strong> Desde tu color seleccionado hasta blanco</li>
                            <li><strong>üìè Tama√±o variable:</strong> Distancia del arrastre = suavidad de transici√≥n</li>
                            <li><strong>üîÑ Modo overlay:</strong> Se mezcla con la imagen existente</li>
                            <li><strong>üëª Semi-transparente:</strong> Mantiene detalles de la imagen original</li>
                        </ul>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>üí° Tips para Gradientes:</h4>
                        <ul>
                            <li>Arrastra l√≠neas <strong>m√°s largas</strong> para transiciones suaves</li>
                            <li>Arrastra l√≠neas <strong>m√°s cortas</strong> para efectos m√°s intensos</li>
                            <li><strong>Experimenta con direcciones:</strong> vertical, horizontal, diagonal</li>
                            <li>√ösalo para crear <strong>efectos de iluminaci√≥n</strong> o <strong>sombreado</strong></li>
                            <li>Comb√≠nalo con otros filtros para <strong>efectos √∫nicos</strong></li>
                        </ul>
                    </div>
                </div>

                <!-- Sistema de Cuentagotas -->
                <div class="help-section">
                    <h3>üíß Herramienta Cuentagotas</h3>
                    <div class="help-subsection">
                        <h4>üéØ Activaci√≥n y Funcionamiento:</h4>
                        <ol>
                            <li><strong>Clic en el bot√≥n üíß</strong> o presiona la tecla <strong>D</strong></li>
                            <li><strong>Aparece inmediatamente</strong> el indicador flotante con el color</li>
                            <li><strong>Mueve el cursor por toda la pantalla</strong> - el indicador te sigue</li>
                            <li><strong>Sobre el canvas:</strong> muestra el color real en tiempo real</li>
                            <li><strong>Fuera del canvas:</strong> muestra color negro por defecto</li>
                            <li><strong>Haz clic sobre el canvas</strong> para seleccionar el color</li>
                            <li><strong>Clic fuera del canvas</strong> desactiva el cuentagotas</li>
                        </ol>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>üé™ Indicador Flotante en Tiempo Real:</h4>
                        <ul>
                            <li>üì± <strong>Siempre visible:</strong> Sigue el cursor por toda la pantalla</li>
                            <li>üé® <strong>Color en vivo:</strong> Muestra el color exacto bajo el cursor</li>
                            <li>üìù <strong>C√≥digo hexadecimal:</strong> Valor del color actualizado constantemente</li>
                            <li>üéØ <strong>Posicionamiento inteligente:</strong> Se mantiene cerca del cursor sin molestar</li>
                            <li>‚ö° <strong>Actualizaci√≥n instant√°nea:</strong> Sin lag ni retrasos</li>
                        </ul>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>‚ú® Caracter√≠sticas Avanzadas:</h4>
                        <ul>
                            <li>üé® <strong>Aplicaci√≥n universal:</strong> Actualiza pincel, texto, flechas y formas autom√°ticamente</li>
                            <li>üéØ <strong>Paleta personalizada:</strong> A√±ade el color seleccionado a la paleta de colores</li>
                            <li>üìä <strong>Barra de estado:</strong> Muestra el color y valores RGB tras seleccionar</li>
                            <li>üîî <strong>Notificaci√≥n visual:</strong> Confirma el color seleccionado temporalmente</li>
                            <li>üñ•Ô∏è <strong>EyeDropper nativo:</strong> En Chrome, acceso directo a captura de pantalla completa</li>
                            <li>‚ö° <strong>M√∫ltiples opciones de cancelaci√≥n:</strong> Bot√≥n, tecla D o ESC</li>
                        </ul>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>üéÆ Controles y Desactivaci√≥n:</h4>
                        <ul>
                            <li><strong>üñ±Ô∏è Clic en el bot√≥n üíß:</strong> Activa/desactiva el modo cuentagotas</li>
                            <li><strong>‚å®Ô∏è Tecla D:</strong> Activa/desactiva el modo cuentagotas</li>
                            <li><strong>‚å®Ô∏è Tecla ESC:</strong> Desactiva el modo cuentagotas</li>
                            <li><strong>üéØ Clic en canvas:</strong> Selecciona color y desactiva autom√°ticamente</li>
                            <li><strong>üñ±Ô∏è Clic fuera del canvas:</strong> Desactiva sin seleccionar color</li>
                            <li><strong>üîÑ Modo persistente:</strong> Permanece activo hasta que lo desactives</li>
                        </ul>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>üí° Tips para Cuentagotas:</h4>
                        <ul>
                            <li>Perfecto para <strong>matching exacto de colores</strong> de tu imagen</li>
                            <li>El <strong>indicador flotante</strong> te permite ver el color antes de seleccionarlo</li>
                            <li>Ideal para <strong>crear paletas cohesivas</strong> con colores de la imagen</li>
                            <li>En Chrome, <strong>autom√°ticamente usa EyeDropper nativo</strong> para captura completa</li>
                            <li>Los colores se guardan en la <strong>paleta personalizada</strong> para uso futuro</li>
                            <li>Comb√≠nalo con <strong>pincel o formas</strong> para usar el color inmediatamente</li>
                        </ul>
                    </div>
                </div>

                <!-- Sistema de Clonaci√≥n -->
                <div class="help-section">
                    <h3>üë• Herramienta de Clonaci√≥n</h3>
                    <div class="help-subsection">
                        <h4>üéØ Proceso de Clonaci√≥n (Nuevo):</h4>
                        <ol>
                            <li><strong>Selecciona la herramienta S</strong> (o presiona tecla S)</li>
                            <li><strong>Arrastra para seleccionar</strong> el √°rea que quieres clonar</li>
                            <li><strong>Aparece un marco punteado verde</strong> con efecto de "marcha de hormigas"</li>
                            <li><strong>Haz clic</strong> en el lugar donde quieres pegar la copia</li>
                            <li><strong>La selecci√≥n se limpia autom√°ticamente</strong> para nueva clonaci√≥n</li>
                        </ol>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>üõ†Ô∏è Caracter√≠sticas de Clonaci√≥n:</h4>
                        <ul>
                            <li><strong>üéØ Selecci√≥n visual:</strong> Marco punteado verde con animaci√≥n</li>
                            <li><strong>üìè Tama√±o flexible:</strong> Selecciona cualquier √°rea rectangular</li>
                            <li><strong>üîÑ Flujo intuitivo:</strong> Seleccionar ‚Üí Ver ‚Üí Pegar</li>
                            <li><strong>üé® Preciso:</strong> Copia exacta p√≠xel por p√≠xel del √°rea seleccionada</li>
                            <li><strong>üîÄ Centrado:</strong> El √°rea se pega centrada en el punto de clic</li>
                        </ul>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>üí° Usos Pr√°cticos de Clonaci√≥n:</h4>
                        <ul>
                            <li><strong>ü©π Reparar imperfecciones:</strong> Eliminar manchas, arrugas, objetos no deseados</li>
            <li><strong>üé®üîÑ Reemplazo de Color (L):</strong> Herramienta avanzada para reemplazar colores espec√≠ficos
                <ul style="margin-left: 20px; margin-top: 5px;">
                    <li>üéØ <strong>Cuentagotas integrado:</strong> Selecciona colores directamente de la imagen</li>
                    <li>üéöÔ∏è <strong>Tolerancia ajustable:</strong> Controla la precisi√≥n del reemplazo (0-100%)</li>
                    <li>üé≠ <strong>5 Modos de reemplazo:</strong> S√≥lido, Gradiente, Inteligente, Solo Matiz, Solo Saturaci√≥n</li>
                    <li>üëÅÔ∏è <strong>Vista previa en tiempo real:</strong> Ve los cambios antes de aplicarlos</li>
                    <li>ü™Ñ <strong>Varita M√°gica:</strong> Selecci√≥n autom√°tica de colores similares</li>
                    <li>üìä <strong>Estad√≠sticas en tiempo real:</strong> P√≠xeles afectados, porcentaje, colores √∫nicos</li>
                    <li>‚ú® <strong>Colores sugeridos:</strong> Paleta inteligente basada en teor√≠a del color</li>
                </ul>
            </li>
                            <li><strong>üîÅ Duplicar elementos:</strong> Copiar flores, ojos, texturas, patrones</li>
                            <li><strong>üñºÔ∏è Extender fondos:</strong> Rellenar √°reas con texturas existentes</li>
                            <li><strong>üé® Efectos art√≠sticos:</strong> Crear patrones repetitivos o simetr√≠as</li>
                            <li><strong>üìê Correcci√≥n de composici√≥n:</strong> Duplicar elementos en nuevas posiciones</li>
                        </ul>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>‚ö†Ô∏è Tips Importantes:</h4>
                        <ul>
                            <li>Haz <strong>selecciones suficientemente grandes</strong> (m√≠nimo 5x5 p√≠xeles)</li>
                            <li>El <strong>marco verde punteado</strong> indica que tienes una selecci√≥n activa</li>
                            <li>Para resultados naturales, clona desde <strong>√°reas similares</strong> en iluminaci√≥n y textura</li>
                            <li>La clonaci√≥n se centra autom√°ticamente en el punto donde haces clic</li>
                        </ul>
                    </div>
                </div>

                <!-- Sistema de Formas Geom√©tricas -->
                <div class="help-section">
                    <h3>üü¢ Panel Flotante de Formas Geom√©tricas</h3>
                    <p>Haz clic en el bot√≥n üü¢ para abrir un panel flotante con 22 formas diferentes organizadas por categor√≠as. Configura colores, grosor y propiedades especiales desde un men√∫ intuitivo.</p>
                    <div class="help-subsection">
                        <h4>üì¶ Categor√≠as de Formas Disponibles:</h4>
                        <ul>
                            <li><strong>üîµ Formas B√°sicas:</strong> C√≠rculo, Cuadrado, Rect√°ngulo, Elipse</li>
                            <li><strong>üìè L√≠neas:</strong> L√≠nea Recta, L√≠nea Diagonal</li>
                            <li><strong>üî∫ Pol√≠gonos:</strong> Tri√°ngulo, Pent√°gono, Hex√°gono, Oct√°gono</li>
                            <li><strong>‚ú® Formas Especiales:</strong> Estrella, Rombo, Trapecio, Paralelogramo</li>
                            <li><strong>üéØ S√≠mbolos:</strong> Coraz√≥n, Cruz, Nube, Rayo</li>
                            <li><strong>üîÆ Formas Avanzadas:</strong> Espiral, Arco, Sector Circular, Engranaje</li>
                        </ul>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>üõ†Ô∏è Crear y Personalizar Formas:</h4>
                        <ol>
                            <li><strong>Haz clic en el bot√≥n üü¢</strong> (o presiona tecla U) para abrir el panel flotante</li>
                            <li><strong>Selecciona el tipo de forma</strong> desde el men√∫ desplegable organizado por categor√≠as</li>
                            <li><strong>Configura las propiedades:</strong>
                                <ul>
                                    <li>üé® <strong>Estilo:</strong> Solo relleno, solo contorno, o ambos</li>
                                    <li>üåà <strong>Colores:</strong> Color de relleno y color de contorno independientes</li>
                                    <li>üìè <strong>Grosor:</strong> Ajusta el grosor del contorno</li>
                                    <li>üîç <strong>Opacidad:</strong> Transparencia de la forma</li>
                                </ul>
                            </li>
                            <li><strong>La herramienta se activa autom√°ticamente</strong> al abrir el panel</li>
                            <li><strong>Haz clic y arrastra</strong> en el canvas para crear la forma</li>
                        </ol>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>‚öôÔ∏è Formas con Controles Especiales:</h4>
                        <ul>
                            <li><strong>‚≠ê Estrella:</strong> Controla n√∫mero de puntas (3-20) y profundidad</li>
                            <li><strong>üåÄ Espiral:</strong> Ajusta el n√∫mero de vueltas (1-10)</li>
                            <li><strong>üåô Arco/üç∞ Sector:</strong> Define √°ngulos de inicio y fin (0-360¬∞)</li>
                            <li><strong>‚öôÔ∏è Engranaje:</strong> Configura n√∫mero de dientes (6-20)</li>
                        </ul>
                    </div>
                    
                    <div class="help-subsection">
                        <h4>üí° Tips para Formas:</h4>
                        <ul>
                            <li>Haz <strong>clic en una forma existente</strong> para seleccionarla y editarla</li>
                            <li>Los <strong>handles de esquina</strong> permiten redimensionar</li>
                            <li>Usa <strong>Shift+Arrastrar</strong> para mantener proporciones (pr√≥ximamente)</li>
                            <li>Las formas se <strong>integran con el historial</strong> - puedes deshacer/rehacer</li>
                            <li>Combina diferentes estilos para crear <strong>efectos √∫nicos</strong></li>
                        </ul>
                    </div>
                </div>

                <!-- Sistema Unificado -->
                <div class="help-section">
                    <h3>üîó Sistema de Color y Grosor Unificado</h3>
                    <div class="help-grid">
                        <div class="help-item">
                            <strong>üé® Paleta de Colores (P):</strong><br>
                            ‚Ä¢ Panel flotante con colores predefinidos<br>
                            ‚Ä¢ Selector de color personalizado<br>
                            ‚Ä¢ Se aplica a todas las herramientas
                        </div>
                        <div class="help-item">
                            <strong>üìè Control de Grosor (R):</strong><br>
                            ‚Ä¢ Panel flotante con grosores predefinidos<br>
                            ‚Ä¢ Control deslizante personalizado<br>
                            ‚Ä¢ Funciona para pincel, borrador y flechas
                        </div>
                        <div class="help-item">
                            <strong>üü¢ Panel de Formas (U):</strong><br>
                            ‚Ä¢ Panel flotante con 22 formas geom√©tricas<br>
                            ‚Ä¢ Organizadas en 6 categor√≠as diferentes<br>
                            ‚Ä¢ Configuraci√≥n completa de propiedades
                        </div>
                    </div>
                </div>

                <!-- Edici√≥n de Im√°genes -->
                <div class="help-section">
                    <h3>üé® Edici√≥n y Filtros</h3>
                    <div class="help-grid">
                        <div class="help-item">
                            <strong>Ajustes B√°sicos:</strong><br>
                                                          Brillo, Contraste, Saturaci√≥n, Matiz, Exposici√≥n, Temperatura
                        </div>
                        <div class="help-item">
                            <strong>üé≠ Filtros R√°pidos:</strong><br>
                            Original, Vintage, B&N, Sepia, Polaroid, C√°lido, Fr√≠o, Dram√°tico, Suave
                        </div>
                        <div class="help-item">
                            <strong>Transformaciones:</strong><br>
                            Rotar 90, Voltear horizontal/vertical, Redimensionar
                        </div>
                        <div class="help-item">
                            <strong>Efectos:</strong><br>
                                                                üåÄ Desenfoque, üîç Enfoque, üå´Ô∏è Vi√±eta, üåæ Grano, ‚ú® Auto-mejora (Ctrl+L)
                        </div>
                    </div>
                </div>

                <!-- Guardado y Exportaci√≥n -->
                <div class="help-section">
                    <h3>üíæ Guardar y Exportar</h3>
                    <ul>
                        <li><strong>üíæ Guardar (Ctrl+S):</strong> Descarga r√°pida en formato PNG ao directorio de descargas</li>
                        <li><strong>üì§ Guardar como:</strong> Modal avanzado con opciones:
                            <ul>
                                <li>üìÑ <strong>Nombre personalizable:</strong> Puedes elegir el nombre del archivo</li>
                                <li>üìÅ <strong>Directorio:</strong> Se guarda en la carpeta de Descargas (limitaci√≥n del navegador)</li>
                                <li><strong>Formatos:</strong> PNG, JPEG, WebP</li>
                                <li><strong>Calidad ajustable:</strong> Para JPEG/WebP</li>
                                <li><strong>Tama√±os predefinidos:</strong> Original, HD, Redes Sociales, Web</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <!-- Historial -->
                <div class="help-section">
                    <h3>üìö Historial Inteligente</h3>
                    <ul>
                        <li><strong>‚è™ Ctrl+Z:</strong> Deshacer √∫ltima acci√≥n</li>
                        <li><strong>‚è© Ctrl+Y:</strong> Rehacer acci√≥n deshecha</li>
                        <li><strong>ü§ñ Autom√°tico:</strong> Se guarda autom√°ticamente cada cambio importante</li>
                        <li><strong>üì¶ Incluye todo:</strong> Texto, flechas, ediciones, filtros</li>
                        <li><strong>‚öñÔ∏è L√≠mite:</strong> √öltimas 30 acciones para optimizar memoria</li>
                    </ul>
                </div>

                <!-- Tips y Trucos -->
                <div class="help-section">
                    <h3>üí° Tips y Trucos</h3>
                    <ul>
                        <li>Usa <strong>Ctrl+A</strong> para seleccionar toda la imagen r√°pidamente</li>
                        <li>Los <strong>tooltips aparecen al pasar el rat√≥n</strong> por las herramientas</li>
                        <li>Presiona <strong>ESC</strong> para cancelar selecciones o cerrar paneles</li>
                        <li>Las im√°genes se <strong>ajustan autom√°ticamente</strong> al tama√±o de ventana</li>
                        <li>Usa la <strong>rueda del rat√≥n</strong> para hacer zoom din√°mico</li>
                        <li>Los <strong>paneles flotantes</strong> se cierran al hacer clic fuera</li>
                        <li>Puedes <strong>pegar im√°genes desde el portapapeles</strong> con Ctrl+V</li>
                        <li>El <strong>histograma</strong> muestra la distribuci√≥n de colores en tiempo real</li>
                    </ul>
                </div>

                <!-- Informaci√≥n T√©cnica -->
                <div class="help-section">
                    <h3>üîß Informaci√≥n T√©cnica</h3>
                    <ul>
                        <li><strong>üì± Versi√≥n:</strong> Editor de Im√°genes Profesional v2.0</li>
                        <li><strong>‚ö° Tecnolog√≠a:</strong> HTML5 Canvas, CSS3, JavaScript Vanilla</li>
                        <li><strong>üåê Compatibilidad:</strong> Navegadores modernos, responsive design</li>
                        <li><strong>üìä L√≠mites:</strong> Im√°genes hasta 4000x4000px, historial de 30 acciones</li>
                        <li><strong>üöÄ Optimizado:</strong> Rendimiento mejorado con t√©cnicas de debouncing</li>
                    </ul>
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="btn primary" onclick="closeHelpModal()">‚úÖ Entendido</button>
            </div>
        </div>
    </div>

    <script>
        // =================================================================================
        // SECTION: APP STATE & CONFIGURATION
        // =================================================================================
        
        let canvas, ctx;
        
        const appState = {
            currentTool: 'select',
            isDrawing: false,
            isDragging: false,
            isResizing: false,
            dragStart: { x: 0, y: 0 },
            dragOffset: { x: 0, y: 0 },
            currentResizeHandle: null,
            textClickPosition: { x: 0, y: 0 },
            editingTextElement: null,
            historyIndex: -1,
            currentLayer: 0,
            zoomLevel: 1,
            panX: 0,
            panY: 0,
            isDraggingObject: false,
            eyedropperActive: false,
            lockStatusBarColor: false,
        };
        
        const imageState = {
            originalImage: null,
            currentImage: null,
            selectionActive: false,
            selectionRect: { x: 0, y: 0, width: 0, height: 0 },
            history: [],
            layers: [],
            arrows: [],
            shapes: [],
            textElements: [],
            brushStrokes: [],
            currentArrow: null,
            currentShape: null,
            currentGradient: null,
            currentBrushStroke: null,
            selectedObject: null,
            activeHandles: [],
            cloneSelection: null,
            clonedImageData: null,
            pauseCloneAnimation: false,
            currentFile: null,
            // Estado para recorte con puntos de control
            cropHandles: {
                active: false,
                rect: null,
                dragging: null,
                handleSize: 10
            }
        };
        
        const toolSettings = {
            globalThickness: 5,
            currentColor: '#FF0000',
            brush: {
                hardness: 100,
                opacity: 100,
            },
            arrow: {
                type: 'simple',
                thickness: 5,
                headSize: 15,
                opacity: 100,
            },
            text: {
                size: 24,
                font: 'Arial',
                style: 'normal',
                align: 'left',
            },
            shape: {
                type: 'circle',
                style: 'fill',
                strokeWidth: 3,
                fillColor: '#FF0000',
                strokeColor: '#000000',
                opacity: 100,
                starSpikes: 5,
                starDepth: 0.5,
                spiralTurns: 3,
                arcStartAngle: 0,
                arcEndAngle: 180,
                gearTeeth: 8,
            },
            filters: {
                brightness: 0, contrast: 0, saturation: 0, hue: 0,
                exposure: 0, temperature: 0, blur: 0, sharpen: 0,
                vignette: 0, grain: 0
            }
        };

        const defaultSettings = {
            canvas: {
                size: 'fullscreen',
                width: 1920,
                height: 1080,
                backgroundColor: '#FFFFFF'
            },
            tools: {
                defaultTool: 'select',
                color: '#FF0000',
                thickness: 5,
                fontSize: 24
            },
            performance: {
                renderQuality: 'high',
                historyLimit: 30,
                autoSave: true
            },
            ui: {
                theme: 'dark',
                showTooltips: true,
                enableAnimations: true
            }
        };

        let appSettings = { ...defaultSettings };
        
        // Cache for DOM elements to improve performance
        const domElements = {};

        // =================================================================================
        // SECTION: INITIALIZATION
        // =================================================================================

        document.addEventListener('DOMContentLoaded', function() {
            cacheDOMElements();
            loadSettings(); // Cargar configuraci√≥n de IA al inicio
            initializeCanvas();
            setupEventListeners();
            setupKeyboardShortcuts();
            initializeUI();
            initializeModernFeatures();
            
            // Mostrar la barra de estado al inicio
            setTimeout(() => {
                updateStatusBar();
            }, 100);
            
            setTimeout(() => {
                imageState.history = [];
                appState.historyIndex = -1;
                saveToHistory();
            }, 100);
        });

        function cacheDOMElements() {
            const ids = [
                'fileInput', 'modernApiIndicator', 'canvasContainer', 'dropZone',
                'canvasWrapper', 'mainCanvas', 'selectionOverlay', 'canvasWidth', 'canvasHeight',
                'toolProperties', 'brushProperties', 'arrowProperties', 'textProperties', 'shapeProperties',
                'histogramCanvas', 'layersList', 'zoomLevel', 'mousePos', 'pixelInfo',
                'filePathInfo', 'imageDimensions', 'fileSizeInfo', 'currentTool',
                'settingsModal', 'exportModal', 'exportFileName', 'modernApiInfo', 'fallbackInfo',
                'exportFormat', 'qualityControl', 'exportQuality', 'exportQualityValue', 'exportSize',
                'colorPalettePanel', 'thicknessPanel', 'shapesPanel', 'textModal',
                'textInput', 'textPreview', 'helpModal', 'textFontModal', 'textSizeModal', 'textSizeModalValue',
                'textBoldModal', 'textItalicModal', 'textUnderlineModal', 'textColorPickerModal',
                'defaultCanvasSize', 'customSizeControls', 'customWidth', 'customHeight', 'defaultBackgroundColor',
                'canvasSizePreview', 'defaultTool', 'defaultToolColor', 'defaultThickness', 'defaultThicknessValue',
                'defaultFontSize', 'defaultFontSizeValue', 'renderQuality', 'historyLimit', 'autoSave',
                'defaultTheme', 'showTooltips', 'enableAnimations'
            ];
            ids.forEach(id => domElements[id] = document.getElementById(id));
        }

        function initializeCanvas() {
            canvas = domElements.mainCanvas;
            if (!canvas) return;
            
            ctx = canvas.getContext('2d', { willReadFrequently: true });
            if (!ctx) return;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = 800 * dpr;
            canvas.height = 600 * dpr;
            canvas.style.width = '800px';
            canvas.style.height = '600px';
            
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, 800, 600);
            
            if (domElements.histogramCanvas) {
                domElements.histogramCanvas.width = 248;
                domElements.histogramCanvas.height = 80;
            }
        }
        
        function initializeUI() {
            if (domElements.exportFormat) {
                domElements.exportFormat.addEventListener('change', function() {
                    if (domElements.qualityControl) {
                        domElements.qualityControl.style.display = (this.value === 'jpeg' || this.value === 'webp') ? 'block' : 'none';
                    }
                });
            }
            
            document.querySelectorAll('.slider').forEach(slider => {
                slider.addEventListener('input', () => updateSliderUI(slider.id, slider.value));
            });
            
            document.querySelectorAll('.color-swatch, .quick-color-swatch').forEach(swatch => {
                swatch.addEventListener('click', () => {
                    const color = swatch.dataset.color;
                    selectQuickColor(color);
                    closeAllFloatingPanels();
                });
            });
            
            document.querySelectorAll('.thickness-option').forEach(option => {
                option.addEventListener('click', () => {
                    const thickness = option.dataset.size;
                    selectThickness(thickness);
                    
                    document.querySelectorAll('.thickness-option').forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    
                    closeAllFloatingPanels();
                });
            });
            
            updateAllToolPropertiesUI();
        }

        // =================================================================================
        // SECTION: EVENT LISTENERS
        // =================================================================================

        function setupEventListeners() {
            const fileInputEl = domElements.fileInput || document.getElementById('fileInput');
            if (fileInputEl) {
                fileInputEl.addEventListener('change', handleFileSelect);
                if (!domElements.fileInput) domElements.fileInput = fileInputEl;
            }
            domElements.canvasContainer.addEventListener('dragover', handleDragOver);
            domElements.canvasContainer.addEventListener('dragleave', handleDragLeave);
            domElements.canvasContainer.addEventListener('drop', handleDrop);

                    canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('wheel', handleCanvasWheel);
        canvas.addEventListener('mousemove', updateZoomCursor);
        domElements.canvasContainer.addEventListener('wheel', handleContainerWheel);
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        // Event listeners para reemplazo de color
        canvas.addEventListener('click', handleColorReplaceClick);
        canvas.addEventListener('mousemove', handleColorReplaceMouseMove);
            
            // Eventos para cambiar cursor con CTRL
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Control') {
                    document.querySelectorAll('#mainCanvas').forEach(canvas => {
                        canvas.dispatchEvent(new MouseEvent('mousemove', { ctrlKey: true }));
                    });
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.key === 'Control') {
                    document.querySelectorAll('#mainCanvas').forEach(canvas => {
                        canvas.dispatchEvent(new MouseEvent('mousemove', { ctrlKey: false }));
                    });
                }
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    clearSelection();
                    if (imageState.cloneSelection) {
                        clearCloneSelection();
                    }
                }
                if (e.key === 'Delete' && imageState.selectedObject) {
                    deleteSelectedObject();
                }
            });
            
            document.addEventListener('click', e => {
                if (!e.target.closest('.floating-panel, [data-tool="palette"], [data-tool="thickness"], [data-tool="shapes"]')) {
                    closeAllFloatingPanels();
                }
            });

            document.addEventListener('paste', e => {
                const items = e.clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.startsWith('image/')) {
                        loadImage(items[i].getAsFile());
                        break;
                    }
                }
            });
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', e => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                const keyMap = {
                    'v': 'select', 'c': 'crop', 'b': 'brush', 'e': 'eraser', 't': 'text',
                    'a': 'arrow', 'g': 'gradient', 's': 'clone', 'j': 'heal', 'z': 'zoom',
                };
                
                if (e.ctrlKey || e.metaKey) {
                    const shortcutMap = { 'z': undo, 'y': redo, 'o': () => { const el = document.getElementById('fileInput'); if (el) el.click(); }, 's': saveImage };
                    if (e.shiftKey && e.key.toLowerCase() === 'z') {
                        redo();
                        e.preventDefault();
                    } else if (shortcutMap[e.key.toLowerCase()]) {
                        e.preventDefault();
                        shortcutMap[e.key.toLowerCase()]();
                    }
                                 } else if (e.key.toLowerCase() === 'd') {
                    selectTool('eyedropper');
                } else if (keyMap[e.key.toLowerCase()]) {
                    selectTool(keyMap[e.key.toLowerCase()]);
                } else if (e.key.toLowerCase() === 'u') {
                    activateShapesTool();
                } else if (e.key.toLowerCase() === 'p') {
                    toggleColorPalette();
                } else if (e.key.toLowerCase() === 'r') {
                    toggleThicknessPanel();
                } else if (e.key.toLowerCase() === 'l') {
                    selectTool('colorReplace');
                } else if (e.key === 'Enter' && appState.currentTool === 'crop' && imageState.cropHandles.active) {
                    // Aplicar recorte con Enter
                    applyCropFromHandles();
                } else if (e.key === 'Escape') {
                    if (appState.currentTool === 'crop') {
                        // Si estamos en modo recorte, Escape resetea al √°rea completa en lugar de desactivar
                        activateCropHandles();
                    } else {
                        clearSelection();
                        if (imageState.cropHandles.active) {
                            deactivateCropHandles();
                        }
                    }
                    if (imageState.cloneSelection) {
                        clearCloneSelection();
                    }
                    closeAllFloatingPanels();
                    closeModal('textModal');
                    closeModal('helpModal');
                    closeModal('settingsModal');
                } else if (e.key.toLowerCase() === 'ctrl+,') {
                    e.preventDefault();
                    showSettingsModal();
                }
            });
        }

        // =================================================================================
        // SECTION: MOUSE & DRAG EVENT HANDLERS
        // =================================================================================

        function handleMouseDown(e) {
            const pos = getCanvasMousePos(e);
            appState.dragStart = pos;
            
            // Manejo especial para clic derecho en herramienta de clonado
            if (appState.currentTool === 'clone' && e.button === 2) {
                // Clic derecho: pegar clonado
                if (imageState.clonedImageData && imageState.cloneSelection && !imageState.cloneSelection.active) {
                    pasteClonedSelection(pos.x, pos.y);
                }
                return;
            }
            
            appState.isDrawing = true;

            const objectInfo = findObjectAtPoint(pos.x, pos.y);
            
            // Verificar texto ANTES del switch (como funciona con 'select')
            if (appState.currentTool === 'text' && objectInfo.object && objectInfo.object.text) {
                // Hay un texto existente, permitir moverlo
                selectObject(objectInfo.object, false);
                appState.isDraggingObject = true;
                
                const objX = objectInfo.object.x;
                const objY = objectInfo.object.y;
                appState.dragOffset = { x: pos.x - objX, y: pos.y - objY };
                
                if (objectInfo.handle && objectInfo.handle !== 'move') {
                    appState.isDraggingObject = false;
                    handleHandleMouseDown(e, objectInfo.object, objectInfo.handle);
                }
                return;
            }
            
            if (appState.currentTool === 'select' && objectInfo.object) {
                selectObject(objectInfo.object);
                appState.isDraggingObject = true;
                
                let objX, objY;
                if (objectInfo.object.text) {
                    objX = objectInfo.object.x;
                    objY = objectInfo.object.y;
                } else if (objectInfo.object.startX !== undefined) {
                    objX = (objectInfo.object.startX + objectInfo.object.endX) / 2;
                    objY = (objectInfo.object.startY + objectInfo.object.endY) / 2;
                } else {
                    objX = objectInfo.object.x || 0;
                    objY = objectInfo.object.y || 0;
                }
                
                appState.dragOffset = { x: pos.x - objX, y: pos.y - objY };
                
                if (objectInfo.handle && objectInfo.handle !== 'move') {
                    appState.isDraggingObject = false; 
                    handleHandleMouseDown(e, objectInfo.object, objectInfo.handle);
                }
                return;
            }

            switch(appState.currentTool) {
                case 'select':
                    startSelection(pos.x, pos.y);
                    break;
                case 'crop':
                    if (startCropHandleDrag(pos.x, pos.y)) {
                        // Ya se maneja en startCropHandleDrag
                    } else {
                        startSelection(pos.x, pos.y);
                    }
                    break;
                case 'brush':
                    startBrush(pos.x, pos.y);
                    break;
                case 'eraser':
                    startEraser(pos.x, pos.y);
                    break;
                case 'text':
                    handleTextTool(pos.x, pos.y);
                    break;
                case 'arrow':
                    startArrow(pos.x, pos.y);
                    break;
                case 'shapes':
                    startShape(pos.x, pos.y);
                    break;
                case 'gradient':
                    startGradient(pos.x, pos.y);
                    break;
                case 'clone':
                    handleCloneTool(pos.x, pos.y, e);
                    break;
            }
        }

        function handleMouseMove(e) {
            const pos = getCanvasMousePos(e);
            
            // Actualizar info de p√≠xel en barra de estado
            updatePixelInfo(pos.x, pos.y);
            
            if (!appState.isDrawing && !appState.isDraggingObject) {
                updateCursor(e);
                return;
            }

            switch(appState.currentTool) {
                case 'select':
                    if (appState.isDraggingObject && imageState.selectedObject) {
                        moveObject(imageState.selectedObject, pos.x - appState.dragOffset.x, pos.y - appState.dragOffset.y);
                    } else {
                        updateSelection(pos.x, pos.y);
                    }
                    break;
                case 'crop':
                    if (imageState.cropHandles.dragging) {
                        updateCropHandleDrag(pos.x, pos.y);
                    } else {
                        updateSelection(pos.x, pos.y);
                    }
                    break;
                case 'brush':
                    continueBrush(pos.x, pos.y);
                    break;
                case 'eraser':
                    continueEraser(pos.x, pos.y);
                    break;
                case 'arrow':
                    updateArrow(pos.x, pos.y);
                    break;
                case 'shapes':
                    updateShape(pos.x, pos.y);
                    break;
                case 'gradient':
                    updateGradient(pos.x, pos.y);
                    break;
                case 'clone':
                    if (imageState.cloneSelection && imageState.cloneSelection.active) {
                        updateSelection(pos.x, pos.y);
                    }
                    break;
            }
        }

        function handleMouseUp(e) {
            const pos = getCanvasMousePos(e);
            if (appState.isDraggingObject) {
                saveToHistory();
            }
            appState.isDrawing = false;
            appState.isDraggingObject = false;

            switch(appState.currentTool) {
                case 'select':
                    finishSelection();
                    break;
                case 'crop':
                    if (imageState.cropHandles.dragging) {
                        const hasMoved = imageState.cropHandles.dragging.startX !== pos.x || 
                                        imageState.cropHandles.dragging.startY !== pos.y;
                        finishCropHandleDrag();
                        // Aplicar autom√°ticamente el recorte/extensi√≥n al soltar el rat√≥n solo si se ha movido
                        if (hasMoved) {
                            applyCropFromHandles();
                        }
                    } else {
                        finishSelection();
                    }
                    break;
                case 'brush':
                    finishBrush();
                    saveToHistory();
                    break;
                case 'eraser':
                    saveToHistory();
                    break;
                case 'arrow':
                    finishArrow();
                    break;
                case 'shapes':
                    finishShape();
                    break;
                case 'gradient':
                    finishGradient();
                    break;
                case 'clone':
                    // Solo finalizar selecci√≥n con clic izquierdo
                    if (e.button === 0) {
                        finishClone();
                    }
                    break;
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file) loadImage(file);
        }
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) loadImage(file);
        }
        
        // =================================================================================
        // SECTION: CORE LOGIC (IMAGE LOADING, HISTORY, ETC.)
        // =================================================================================

        function loadImage(file) {
            if (!file || !file.type.startsWith('image/')) return;

            // Guardar informaci√≥n del archivo
            imageState.currentFile = file;

            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    const containerRect = domElements.canvasContainer.getBoundingClientRect();
                    const scale = Math.min((containerRect.width - 40) / img.width, (containerRect.height - 40) / img.height, 1);
                    const scaledWidth = Math.floor(img.width * scale);
                    const scaledHeight = Math.floor(img.height * scale);
                    
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = scaledWidth * dpr;
                    canvas.height = scaledHeight * dpr;
                    canvas.style.width = scaledWidth + 'px';
                    canvas.style.height = scaledHeight + 'px';
                    
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                    
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    ctx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
                    
                    // Asegurar que todos los elementos DOM est√©n disponibles
                    cacheDOMElements();
                    
                    resetEditorStateForLoadedImage();
                    imageState.originalImage = img;
                    imageState.currentImage = img;
                    
                    domElements.canvasWidth.value = scaledWidth;
                    domElements.canvasHeight.value = scaledHeight;
                    domElements.dropZone.style.display = 'none';
                    domElements.canvasWrapper.style.display = 'block';
                    
                    selectTool('select');
                    resetZoom();
                    
                    updateStatusBar();
                    updateHistogram();
                    saveToHistory();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function resetFilters() {
            toolSettings.filters = {
                brightness: 0, contrast: 0, saturation: 0, hue: 0,
                exposure: 0, temperature: 0, blur: 0, sharpen: 0,
                vignette: 0, grain: 0
            };
            
            if (canvas) {
                canvas.style.filter = '';
            }
            
            updateAllFilterSlidersUI();
        }

        // Funci√≥n consolidada para resetear el estado del editor
        function resetEditorStateCore(clearOriginalImage = false, saveHistory = false) {
            resetFilters();
            clearSelection();
            imageState.arrows = [];
            imageState.shapes = [];
            imageState.textElements = [];
            imageState.brushStrokes = [];
            clearAllHandles();
            
            imageState.cloneSelection = null;
            imageState.clonedImageData = null;
            imageState.pauseCloneAnimation = false;
            
            if (clearOriginalImage) imageState.originalImage = null;
            
            cleanupToolStates();
            
            if (appState.currentTool !== 'colorReplace') {
                colorReplaceState.sourceColor = null;
                colorReplaceState.targetColor = '#ff0000';
                colorReplaceState.tolerance = 20;
                colorReplaceState.previewMode = false;
                colorReplaceState.active = false;
                colorReplaceState.pickerMode = null;
            }
            
            colorReplaceState.originalImageData = null;
            
            ['colorReplaceFloatingMenu', 'targetColorPalette', 'mousePickerIndicator',
             'colorPickerIndicator', 'colorSuggestions', 'previewIndicator',
             'colorReplaceHelp', 'fullImageColorSelector', 'cursorColorIndicator',
             'colorIndicator', 'magicWandOverlay'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.remove();
            });
            
            ['textModal', 'exportModal', 'settingsModal', 'helpModal'].forEach(id => {
                const modal = document.getElementById(id);
                if (modal) modal.style.display = 'none';
            });
            
            imageState.history = [];
            appState.historyIndex = -1;
            if (saveHistory) saveToHistory();
        }

        function resetEditorState() {
            resetEditorStateCore(true, true);
        }

        function resetEditorStateForLoadedImage() {
            resetEditorStateCore(false, false);
        }

        function saveToHistory() {
            if (!canvas || !ctx) return;

            // Si estamos en medio de un undo, truncar el historial
            if (appState.historyIndex < imageState.history.length - 1) {
                imageState.history = imageState.history.slice(0, appState.historyIndex + 1);
            }

            const state = {
                originalImageSrc: imageState.originalImage ? imageState.originalImage.src : null,
                width: canvas.width,
                height: canvas.height,
                filters: { ...toolSettings.filters },
                cssFilter: canvas.style.filter || '',
                arrows: JSON.parse(JSON.stringify(imageState.arrows)),
                shapes: JSON.parse(JSON.stringify(imageState.shapes)),
                textElements: JSON.parse(JSON.stringify(imageState.textElements)),
                brushStrokes: JSON.parse(JSON.stringify(imageState.brushStrokes)),
            };

            imageState.history.push(state);
            appState.historyIndex = imageState.history.length - 1;

            // Limitar el historial a 30 elementos
            if (imageState.history.length > 30) {
                imageState.history.shift();
                appState.historyIndex--;
            }
        }

        function restoreFromHistory(state) {
            if (!state) return;
            
            clearAllHandles();
            canvas.width = state.width;
            canvas.height = state.height;
            const dpr = window.devicePixelRatio || 1;
            canvas.style.width = (state.width / dpr) + "px";
            canvas.style.height = (state.height / dpr) + "px";

            // Restore original image
            if (state.originalImageSrc) {
                const img = new Image();
                img.onload = () => {
                    imageState.originalImage = img;
                    // Continue restoring other states after image is loaded
                    canvas.style.filter = state.cssFilter || '';
                    toolSettings.filters = { ...state.filters };
                    updateAllFilterSlidersUI();
                    
                    imageState.arrows = state.arrows || [];
                    imageState.shapes = state.shapes || [];
                    imageState.textElements = state.textElements || [];
                    imageState.brushStrokes = state.brushStrokes || [];
                    imageState.selectedObject = null;
                    
                    updateStatusBar();
                    updateHistogram();
                    updateToolButtonHighlight(appState.currentTool); updateCursor(); updateToolPropertiesPanelVisibility();
                    redrawCanvas(); if (appState.currentTool === "crop") { activateCropHandles(); }
                    
                    // Actualizar imagen original del reemplazo de color despu√©s de restaurar
                    if (canvas && ctx) {
                        colorReplaceState.originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    }
                };
                img.src = state.originalImageSrc;
            } else {
                imageState.originalImage = null; // No original image
                // Continue restoring other states
                canvas.style.filter = state.cssFilter || '';
                toolSettings.filters = { ...state.filters };
                updateAllFilterSlidersUI();
                
                imageState.arrows = state.arrows || [];
                imageState.shapes = state.shapes || [];
                imageState.textElements = state.textElements || [];
                imageState.brushStrokes = state.brushStrokes || [];
                imageState.selectedObject = null;
                
                updateStatusBar();
                updateHistogram();
                updateToolButtonHighlight(appState.currentTool); updateCursor(); updateToolPropertiesPanelVisibility();
                redrawCanvas(); if (appState.currentTool === "crop") { activateCropHandles(); }
                
                // Actualizar imagen original del reemplazo de color despu√©s de restaurar
                if (canvas && ctx) {
                    colorReplaceState.originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
            }
        }

        function undo() {
            if (appState.historyIndex > 0) {
                appState.historyIndex--;
                restoreFromHistory(imageState.history[appState.historyIndex]);
            }
        }

        function redo() {
            if (appState.historyIndex < imageState.history.length - 1) {
                appState.historyIndex++;
                restoreFromHistory(imageState.history[appState.historyIndex]);
            }
        }

        function redrawCanvas() {
            if (!ctx) return;
            
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;

            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.clearRect(0, 0, width, height);

            // 1. SIEMPRE dibujar fondo blanco base por si hay √°reas vac√≠as o extensi√≥n
            ctx.save();
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, width, height);
            ctx.restore();

            // Gu√≠a visual del √°rea de recorte/extensi√≥n
            if (imageState.cropHandles.active && imageState.cropHandles.rect) {
                ctx.save();
                const r = imageState.cropHandles.rect;
                
                // Si el rect√°ngulo se sale del canvas, dibujamos una sombra que indique el √°rea total
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.strokeStyle = '#00ffff'; // Cian para visibilidad
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(r.x, r.y, r.width, r.height);
                ctx.restore();
            }

            ctx.save();
            ctx.filter = getFilterCssString();

            if (imageState.originalImage) {
                ctx.drawImage(imageState.originalImage, 0, 0, width, height);
            } else {
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, width, height);
            }
            ctx.restore();

            // Apply non-CSS filters after drawing the main image
            if (toolSettings.filters.vignette > 0) {
                applyVignette(width, height);
            }
            if (toolSettings.filters.grain > 0) {
                applyGrain(canvas.width, canvas.height);
            }
            if (toolSettings.filters.sharpen > 0) {
                applySharpen(canvas.width, canvas.height);
            }

            imageState.shapes.forEach(shape => drawShape(shape));
            imageState.arrows.forEach(arrow => drawArrow(arrow));
            imageState.textElements.forEach(text => drawTextElement(text));
            imageState.brushStrokes.forEach(stroke => drawBrushStroke(stroke));
            
            if (imageState.cloneSelection) {
                drawCloneSelectionOutline();
            }
            
            // Dibujar puntos de control de recorte
            if (imageState.cropHandles.active) {
                drawCropHandles();
            }
        }

        // =================================================================================
        // SECTION: TOOL LOGIC
        // =================================================================================

        function selectTool(tool) {
            if (appState.currentTool === tool) {
                updateToolButtonHighlight(tool);
                return;
            }
            
            // Guardar la herramienta anterior
            const previousTool = appState.currentTool;
            
            // Limpiar estados anteriores
            cleanupToolStates();
            
            // Desactivar eyedropper si estaba activo
            if (appState.eyedropperActive && tool !== 'eyedropper') {
                deactivateEyedropper();
            }
            
            appState.currentTool = tool;
            
            // Activar eyedropper espec√≠ficamente
            if (tool === 'eyedropper') {
                activateEyedropper();
                return;
            }
            
            updateToolButtonHighlight(tool);
            updateCursor();
            updateToolPropertiesPanelVisibility();
            updateStatusBar(); // Actualizar la barra de estado con la nueva herramienta

            // Show relevant tool properties when a tool is selected
            showToolProperties(tool);

            if (tool !== 'shapes' && domElements.shapesPanel?.classList.contains('show')) {
                closeAllFloatingPanels();
            }
            
            if (tool !== 'clone' && imageState.cloneSelection) {
                clearCloneSelection();
            }
            
            // Activar recorte con puntos de control
            if (tool === 'crop') {
                activateCropHandles();
            } else if (imageState.cropHandles.active) {
                deactivateCropHandles();
            }
            
            // Activar herramienta de reemplazo de color
            if (tool === 'colorReplace') {
                initializeColorReplace();
            } else {
                // Si est√°bamos en reemplazo de color, actualizar la imagen original con los cambios aplicados
                if (previousTool === 'colorReplace' && canvas && ctx) {
                    colorReplaceState.originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
                
                // Limpiar menu de reemplazo de color si no est√° activo
                const colorReplaceMenu = document.getElementById('colorReplaceFloatingMenu');
                if (colorReplaceMenu) {
                    colorReplaceMenu.remove();
                }
            }
        }
        
        function updateToolButtonHighlight(tool) {
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const toolBtn = document.querySelector(`[data-tool="${tool}"]`);
            if (toolBtn) {
                toolBtn.classList.add('active');
            }
        }
        
        // =================================================================================
        // SECTION: GRADIENT TOOL
        // =================================================================================
        
        function startGradient(x, y) {
            imageState.currentGradient = {
                startX: x, startY: y, endX: x, endY: y,
                colors: [toolSettings.currentColor, '#FFFFFF'],
                type: 'linear',
                id: Date.now()
            };
        }

        function updateGradient(x, y) {
            if (!imageState.currentGradient) return;
            
            imageState.currentGradient.endX = x;
            imageState.currentGradient.endY = y;
            
            redrawCanvas();
            
            ctx.save();
            ctx.globalAlpha = 0.7; 
            drawGradientPreview(imageState.currentGradient);
            ctx.restore();
        }

        function finishGradient() {
            if (!imageState.currentGradient) return;
            
            const gradient = imageState.currentGradient;
            const dx = gradient.endX - gradient.startX;
            const dy = gradient.endY - gradient.startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 20) {
                ctx.save();
                applyGradient(gradient);
                ctx.restore();
                
                imageState.currentGradient = null;
                saveToHistory();
            } else {
                imageState.currentGradient = null;
                redrawCanvas(); 
            }
        }

        function drawGradientPreview(gradientData) {
            const { startX, startY, endX, endY, colors, type } = gradientData;
            
            let gradient;
            if (type === 'radial') {
                const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                gradient = ctx.createRadialGradient(startX, startY, 0, startX, startY, radius);
            } else {
                gradient = ctx.createLinearGradient(startX, startY, endX, endY);
            }
            
            gradient.addColorStop(0, colors[0]);
            gradient.addColorStop(1, colors[1]);
            
            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = 'overlay';
            ctx.fillRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function applyGradient(gradientData) {
            const { startX, startY, endX, endY, colors, type } = gradientData;
            
            let gradient;
            if (type === 'radial') {
                const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                gradient = ctx.createRadialGradient(startX, startY, 0, startX, startY, radius);
            } else {
                gradient = ctx.createLinearGradient(startX, startY, endX, endY);
            }
            
            gradient.addColorStop(0, colors[0]);
            gradient.addColorStop(1, colors[1]);
            
            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = 'overlay';
            ctx.globalAlpha = 0.5;
            ctx.fillRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
        }
        
        // =================================================================================
        // SECTION: CLONE TOOL
        // =================================================================================
        
        function handleCloneTool(x, y, event) {
            if (appState.currentTool !== 'clone') return;
            
            // Solo manejar clic izquierdo para selecci√≥n
            if (!imageState.cloneSelection) {
                startCloneSelection(x, y);
            } else if (imageState.cloneSelection.active) {
                return;
            }
            // El pegado ahora se maneja directamente en handleMouseDown con clic derecho
        }

        function startCloneSelection(x, y) {
            imageState.cloneSelection = {
                startX: x,
                startY: y,
                endX: x,
                endY: y,
                active: true
            };

        }

        function continueClone(x, y) {
            if (imageState.cloneSelection && imageState.cloneSelection.active) {
                updateCloneSelection(x, y);
            }
        }

        function updateCloneSelection(x, y) {
            if (!imageState.cloneSelection || !imageState.cloneSelection.active) return;
            
            imageState.cloneSelection.endX = x;
            imageState.cloneSelection.endY = y;
            
            redrawCanvas();
            drawCloneSelectionOutline();
        }

        function finishClone() {
            if (imageState.cloneSelection && imageState.cloneSelection.active) {
                finishCloneSelection();
            }
        }

        function finishCloneSelection() {
            if (!imageState.cloneSelection) return;
            
            const selection = imageState.cloneSelection;
            
            const left = Math.min(selection.startX, selection.endX);
            const top = Math.min(selection.startY, selection.endY);
            const width = Math.abs(selection.endX - selection.startX);
            const height = Math.abs(selection.endY - selection.startY);
            
            if (width < 5 || height < 5) {
                clearCloneSelection();
                return;
            }
            
            try {
                const dpr = window.devicePixelRatio || 1;
                imageState.clonedImageData = ctx.getImageData(left * dpr, top * dpr, width * dpr, height * dpr);
                imageState.cloneSelection.active = false;
                imageState.cloneSelection.rect = { left, top, width, height };
                
                redrawCanvas();
                drawCloneSelectionOutline();
                
                // Actualizar cursor para indicar modo de pegado
                canvas.style.cursor = 'copy';
                
                // Cambiar el √≠cono del bot√≥n de clonado para indicar modo de pegado
                const cloneBtn = document.querySelector('[data-tool="clone"]');
                if (cloneBtn) {
                    cloneBtn.innerHTML = 'üìã<div class="tooltip">Clonar partes de la imagen (S)<br>Clic izq: seleccionar √°rea<br>Clic der: pegar<br>Escape: limpiar</div>';
                }
                
            } catch (error) {
                clearCloneSelection();
            }
        }

        function pasteClonedSelection(x, y) {
            if (!imageState.clonedImageData || !imageState.cloneSelection) {
                return;
            }
            
            const rect = imageState.cloneSelection.rect;
            const pasteX = x - rect.width / 2;
            const pasteY = y - rect.height / 2;
            
            try {
                const dpr = window.devicePixelRatio || 1;
                const width = canvas.width / dpr;
                const height = canvas.height / dpr;
                
                // Crear un canvas temporal con solo la imagen original
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                
                // Aplicar la misma transformaci√≥n DPR que en redrawCanvas
                tempCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                tempCtx.imageSmoothingEnabled = true;
                tempCtx.imageSmoothingQuality = 'high';
                
                // Dibujar solo la imagen original con las dimensiones correctas
                if (imageState.originalImage) {
                    tempCtx.drawImage(imageState.originalImage, 0, 0, width, height);
                } else {
                    tempCtx.fillStyle = '#FFFFFF';
                    tempCtx.fillRect(0, 0, width, height);
                }
                
                // Aplicar el pegado clonado con coordenadas consistentes
                tempCtx.putImageData(imageState.clonedImageData, pasteX * dpr, pasteY * dpr);
                
                // Crear nueva imagen original con el pegado incluido (s√≠ncrono)
                const newImg = new Image();
                newImg.onload = () => {
                    imageState.originalImage = newImg;
                    
                    // Asegurar que no hay ning√∫n objeto seleccionado despu√©s del clonado
                    imageState.selectedObject = null;
                    clearAllHandles();
                    
                    redrawCanvas(); // Redibujar todo incluyendo elementos vectoriales
                    saveToHistory(); // <--- MOVED HERE
                };
                newImg.src = tempCanvas.toDataURL('image/png');
                
            } catch (error) {
                clearCloneSelection();
            }
        }

        function drawCloneSelectionOutline() {
            if (!imageState.cloneSelection) return;
            
            const selection = imageState.cloneSelection;
            const left = Math.min(selection.startX, selection.endX);
            const top = Math.min(selection.startY, selection.endY);
            const width = Math.abs(selection.endX - selection.startX);
            const height = Math.abs(selection.endY - selection.startY);
            
            ctx.save();
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.globalCompositeOperation = 'difference';
            
            ctx.beginPath();
            ctx.rect(left, top, width, height);
            ctx.stroke();
            
            const time = Date.now() * 0.01;
            ctx.setLineDash([8, 4]);
            ctx.lineDashOffset = -time % 12;
            ctx.stroke();
            
            ctx.restore();
        }

        function clearCloneSelection() {
            imageState.cloneSelection = null;
            imageState.clonedImageData = null;
            imageState.pauseCloneAnimation = false;
            redrawCanvas();
            updateCursor(); // Restaurar cursor normal
            
            // Restaurar √≠cono original del bot√≥n de clonado
            const cloneBtn = document.querySelector('[data-tool="clone"]');
            if (cloneBtn) {
                cloneBtn.innerHTML = 'üë•<div class="tooltip">Clonar partes de la imagen (S)<br>Clic izq: seleccionar √°rea<br>Clic der: pegar<br>Escape: limpiar</div>';
            }
        }

        function initCloneAnimation() {
            let lastAnimationTime = 0;
            setInterval(() => {
                if (imageState.cloneSelection && !imageState.cloneSelection.active && !imageState.pauseCloneAnimation) {
                    // Solo redibujar si han pasado al menos 150ms desde la √∫ltima vez
                    const now = Date.now();
                    if (now - lastAnimationTime > 150) {
                        redrawCanvas();
                        lastAnimationTime = now;
                    }
                }
            }, 150);
        }

        document.addEventListener('DOMContentLoaded', initCloneAnimation);

        // =================================================================================
        // SECTION: CROP HANDLES TOOL
        // =================================================================================
        
        function activateCropHandles() {
            // Inicializar el rect√°ngulo de recorte con toda la imagen
            const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
            const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
            
            imageState.cropHandles.active = true;
            imageState.cropHandles.rect = {
                x: 0,
                y: 0,
                width: canvasWidth,
                height: canvasHeight
            };
            
            redrawCanvas();
            drawCropHandles();
            

        }
        
        function deactivateCropHandles() {
            imageState.cropHandles.active = false;
            imageState.cropHandles.rect = null;
            imageState.cropHandles.dragging = null;
            redrawCanvas();
        }
        
        function drawCropHandles() {
            if (!imageState.cropHandles.active || !imageState.cropHandles.rect) {
                return;
            }
            
            const rect = imageState.cropHandles.rect;
            const handleSize = imageState.cropHandles.handleSize;
            
            ctx.save();
            
            // Dibujar borde del √°rea de recorte con alta visibilidad (doble l√≠nea)
            ctx.setLineDash([]);
            ctx.strokeStyle = '#000000'; // Borde exterior negro
            ctx.lineWidth = 3;
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            
            ctx.strokeStyle = '#00ffff'; // Borde interior cian brillante
            ctx.lineWidth = 1;
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            
            // Dibujar puntos de control
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            
            const handles = getCropHandlePositions(rect);
            
            handles.forEach(handle => {
                ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                ctx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
            });
            
            ctx.restore();
        }
        
        function getCropHandlePositions(rect) {
            const handles = [];
            const centerX = rect.x + rect.width / 2;
            const centerY = rect.y + rect.height / 2;
            
            // 3 puntos arriba
            handles.push({ x: rect.x, y: rect.y, type: 'top-left' });
            handles.push({ x: centerX, y: rect.y, type: 'top-center' });
            handles.push({ x: rect.x + rect.width, y: rect.y, type: 'top-right' });
            
            // 1 punto izquierda (centrado)
            handles.push({ x: rect.x, y: centerY, type: 'middle-left' });
            
            // 1 punto derecha (centrado)
            handles.push({ x: rect.x + rect.width, y: centerY, type: 'middle-right' });
            
            // 3 puntos abajo
            handles.push({ x: rect.x, y: rect.y + rect.height, type: 'bottom-left' });
            handles.push({ x: centerX, y: rect.y + rect.height, type: 'bottom-center' });
            handles.push({ x: rect.x + rect.width, y: rect.y + rect.height, type: 'bottom-right' });
            
            return handles;
        }
        
        function getCropHandleAtPosition(x, y) {
            if (!imageState.cropHandles.active || !imageState.cropHandles.rect) return null;
            
            const handles = getCropHandlePositions(imageState.cropHandles.rect);
            const handleSize = imageState.cropHandles.handleSize;
            
            for (const handle of handles) {
                if (x >= handle.x - handleSize/2 && x <= handle.x + handleSize/2 &&
                    y >= handle.y - handleSize/2 && y <= handle.y + handleSize/2) {
                    return handle;
                }
            }
            return null;
        }
        
        function startCropHandleDrag(x, y) {
            const handle = getCropHandleAtPosition(x, y);
            if (handle) {
                imageState.cropHandles.dragging = {
                    handle: handle,
                    startX: x,
                    startY: y,
                    originalRect: { ...imageState.cropHandles.rect }
                };
                return true;
            }
            return false;
        }
        
        function updateCropHandleDrag(x, y) {
            if (!imageState.cropHandles.dragging) return;
            
            const drag = imageState.cropHandles.dragging;
            const originalRect = drag.originalRect;
            const handleType = drag.handle.type;
            
            let newRect = { ...originalRect };
            
            switch (handleType) {
                case 'top-left':
                    newRect.x = Math.min(x, originalRect.x + originalRect.width - 20);
                    newRect.y = Math.min(y, originalRect.y + originalRect.height - 20);
                    newRect.width = originalRect.width + (originalRect.x - newRect.x);
                    newRect.height = originalRect.height + (originalRect.y - newRect.y);
                    break;
                case 'top-center':
                    newRect.y = Math.min(y, originalRect.y + originalRect.height - 20);
                    newRect.height = originalRect.height + (originalRect.y - newRect.y);
                    break;
                case 'top-right':
                    newRect.y = Math.min(y, originalRect.y + originalRect.height - 20);
                    newRect.width = Math.max(20, x - originalRect.x);
                    newRect.height = originalRect.height + (originalRect.y - newRect.y);
                    break;
                case 'middle-left':
                    newRect.x = Math.min(x, originalRect.x + originalRect.width - 20);
                    newRect.width = originalRect.width + (originalRect.x - newRect.x);
                    break;
                case 'middle-right':
                    newRect.width = Math.max(20, x - originalRect.x);
                    break;
                case 'bottom-left':
                    newRect.x = Math.min(x, originalRect.x + originalRect.width - 20);
                    newRect.width = originalRect.width + (originalRect.x - newRect.x);
                    newRect.height = Math.max(20, y - originalRect.y);
                    break;
                case 'bottom-center':
                    newRect.height = Math.max(20, y - originalRect.y);
                    break;
                case 'bottom-right':
                    newRect.width = Math.max(20, x - originalRect.x);
                    newRect.height = Math.max(20, y - originalRect.y);
                    break;
            }
            
            // No limitamos el rect√°ngulo dentro del canvas para permitir la extensi√≥n
            
            newRect.x = Math.round(newRect.x);
            newRect.y = Math.round(newRect.y);
            newRect.width = Math.round(newRect.width);
            newRect.height = Math.round(newRect.height);
            imageState.cropHandles.rect = newRect;
            redrawCanvas();
            drawCropHandles();
        }
        
        function finishCropHandleDrag() {
            imageState.cropHandles.dragging = null;
        }
        
        function applyCropFromHandles() {
            if (!imageState.cropHandles.active || !imageState.cropHandles.rect) return;
            
            const rect = imageState.cropHandles.rect;
            const dpr = window.devicePixelRatio || 1;
            
            // Desactivar temporalmente los puntos de control
            const originalActive = imageState.cropHandles.active;
            imageState.cropHandles.active = false;
            
            // Guardar el contexto original
            const originalCtx = ctx;
            
            // Crear un canvas temporal con la imagen completa SIN los puntos de control
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // Temporalmente cambiar el contexto global para redibujar limpio
            ctx = tempCtx;
            
            // Configurar el contexto temporal
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Dibujar la imagen completa limpia usando la funci√≥n existente
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;
            
            ctx.clearRect(0, 0, width, height);

            // Gu√≠a visual del √°rea de recorte/extensi√≥n
            if (imageState.cropHandles.active && imageState.cropHandles.rect) {
                ctx.save();
                const r = imageState.cropHandles.rect;
                
                // Si el rect√°ngulo se sale del canvas, dibujamos una sombra que indique el √°rea total
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.strokeStyle = '#00ffff'; // Cian para visibilidad
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(r.x, r.y, r.width, r.height);
                ctx.restore();
            }
            
            ctx.save();
            ctx.filter = getFilterCssString();
            
            if (imageState.originalImage) {
                ctx.drawImage(imageState.originalImage, 0, 0, width, height);
            } else {
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, width, height);
            }
            ctx.restore();
            
            // Aplicar filtros no-CSS
            if (toolSettings.filters.vignette > 0) {
                applyVignette(width, height);
            }
            if (toolSettings.filters.grain > 0) {
                applyGrain(tempCanvas.width, tempCanvas.height);
            }
            if (toolSettings.filters.sharpen > 0) {
                applySharpen(tempCanvas.width, tempCanvas.height);
            }
            
            // Dibujar elementos vectoriales
            imageState.shapes.forEach(shape => drawShape(shape));
            imageState.arrows.forEach(arrow => drawArrow(arrow));
            imageState.textElements.forEach(text => drawTextElement(text));
            imageState.brushStrokes.forEach(stroke => drawBrushStroke(stroke));
            
            // Restaurar el contexto original
            ctx = originalCtx;
            
            // Ahora recortar/extender la parte deseada del canvas limpio
            const finalCanvas = document.createElement('canvas');
            const finalCtx = finalCanvas.getContext('2d');
            finalCanvas.width = rect.width * dpr;
            finalCanvas.height = rect.height * dpr;
            
            // Rellenar con blanco el fondo (para las √°reas de extensi√≥n)
            finalCtx.fillStyle = '#FFFFFF';
            finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
            
            // Usamos drawImage en lugar de getImageData para soportar coordenadas fuera de los l√≠mites (extensi√≥n)
            finalCtx.drawImage(tempCanvas, -rect.x * dpr, -rect.y * dpr);
            
            // Crear la imagen recortada
            const croppedImage = new Image();
            croppedImage.onload = () => {
                imageState.originalImage = croppedImage;
                imageState.currentImage = croppedImage;
                
                const newWidth = rect.width;
                const newHeight = rect.height;
                canvas.width = newWidth * dpr;
                canvas.height = newHeight * dpr;
                canvas.style.width = newWidth + 'px';
                canvas.style.height = newHeight + 'px';
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                imageState.textElements = [];
                imageState.arrows = [];
                imageState.shapes = [];
                imageState.brushStrokes = [];
                imageState.selectedObject = null;
                
                // En lugar de desactivar, reiniciamos el rect√°ngulo al nuevo tama√±o de la imagen
                const finalWidth = canvas.width / dpr;
                const finalHeight = canvas.height / dpr;
                imageState.cropHandles.rect = { x: 0, y: 0, width: finalWidth, height: finalHeight };
                imageState.cropHandles.active = true;
                
                redrawCanvas();
                drawCropHandles();
                updateStatusBar();
                updateHistogram();
                saveToHistory();
                showNotification('‚úÇÔ∏è Imagen ajustada', 'success');
            };
            croppedImage.src = finalCanvas.toDataURL();
        }
        
        // Funciones auxiliares para verificar si elementos est√°n en el √°rea de recorte
        function isShapeInRect(shape, rect) {
            // Verificar si la forma intersecta con el rect√°ngulo de recorte
            return !(shape.endX < rect.x || shape.startX > rect.x + rect.width ||
                     shape.endY < rect.y || shape.startY > rect.y + rect.height);
        }
        
        function isArrowInRect(arrow, rect) {
            // Verificar si la flecha intersecta con el rect√°ngulo de recorte
            return !(Math.max(arrow.startX, arrow.endX) < rect.x || 
                     Math.min(arrow.startX, arrow.endX) > rect.x + rect.width ||
                     Math.max(arrow.startY, arrow.endY) < rect.y || 
                     Math.min(arrow.startY, arrow.endY) > rect.y + rect.height);
        }
        
        function isTextInRect(text, rect) {
            // Verificar si el texto intersecta con el rect√°ngulo de recorte
            return !(text.x > rect.x + rect.width || text.x + (text.width || 100) < rect.x ||
                     text.y > rect.y + rect.height || text.y - (text.height || 20) < rect.y);
        }
        
        function isStrokeInRect(stroke, rect) {
            // Verificar si alg√∫n punto del trazo est√° dentro del rect√°ngulo
            return stroke.points && stroke.points.some(point => 
                point.x >= rect.x && point.x <= rect.x + rect.width &&
                point.y >= rect.y && point.y <= rect.y + rect.height
            );
        }
        
        // Funciones para dibujar elementos en contexto espec√≠fico
        function drawShapeOnContext(ctx, shape) {
            drawShape(shape, ctx);
        }
        
        function drawArrowOnContext(ctx, arrow) {
            drawArrow(arrow, ctx);
        }
        
        function drawTextOnContext(ctx, text) {
            drawTextElement(text, ctx);
        }
        
        function drawBrushStrokeOnContext(ctx, stroke) {
            drawBrushStroke(stroke, ctx);
        }

        // --- Brush & Eraser ---
        function startBrush(x, y) {
            imageState.currentBrushStroke = {
                points: [{x, y}],
                color: toolSettings.currentColor,
                thickness: toolSettings.globalThickness,
                opacity: toolSettings.brush.opacity / 100,
                hardness: toolSettings.brush.hardness,
                id: Date.now()
            };
        }

        function continueBrush(x, y) {
            if (!imageState.currentBrushStroke) return;
            
            imageState.currentBrushStroke.points.push({x, y});
            
            // Dibujar el trazo actual temporalmente
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = imageState.currentBrushStroke.color;
            ctx.lineWidth = imageState.currentBrushStroke.thickness;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = imageState.currentBrushStroke.opacity;
            
            const points = imageState.currentBrushStroke.points;
            if (points.length >= 2) {
                ctx.beginPath();
                ctx.moveTo(points[points.length - 2].x, points[points.length - 2].y);
                ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
                ctx.stroke();
            }
            ctx.restore();
        }

        function finishBrush() {
            if (!imageState.currentBrushStroke) return;
            
            if (imageState.currentBrushStroke.points.length > 1) {
                imageState.brushStrokes.push({ ...imageState.currentBrushStroke });
            }
            
            imageState.currentBrushStroke = null;
        }

        function drawBrushStroke(stroke) {
            if (!stroke || !stroke.points || stroke.points.length < 2) return;
            
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = stroke.color;
            ctx.lineWidth = stroke.thickness;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = stroke.opacity;
            
            ctx.beginPath();
            ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
            
            for (let i = 1; i < stroke.points.length; i++) {
                ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
            }
            
            ctx.stroke();
            ctx.restore();
        }

        function startEraser(x, y) {
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.lineWidth = toolSettings.globalThickness;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = 1.0;
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function continueEraser(x, y) {
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        // --- Arrow ---
        function startArrow(x, y) {
            imageState.currentArrow = {
                type: toolSettings.arrow.type,
                startX: x, startY: y, endX: x, endY: y,
                controlX: null, controlY: null,
                thickness: toolSettings.globalThickness,
                headSize: toolSettings.arrow.headSize,
                color: toolSettings.currentColor,
                opacity: toolSettings.arrow.opacity,
                id: Date.now()
            };
        }

        function updateArrow(x, y) {
            if (!imageState.currentArrow) return;
            
            imageState.currentArrow.endX = x;
            imageState.currentArrow.endY = y;
            
            if (toolSettings.arrow.type === 'curved') {
                const midX = (imageState.currentArrow.startX + x) / 2;
                const midY = (imageState.currentArrow.startY + y) / 2;
                const dx = x - imageState.currentArrow.startX;
                const dy = y - imageState.currentArrow.startY;
                const length = Math.sqrt(dx * dx + dy * dy) || 1;
                const curvature = Math.max(30, length * 0.25);
                imageState.currentArrow.controlX = midX - dy / length * curvature;
                imageState.currentArrow.controlY = midY + dx / length * curvature;
            }
            
            redrawCanvas();
            
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.setLineDash([5, 5]);
            drawArrow(imageState.currentArrow);
            ctx.restore();
        }

        function finishArrow() {
            if (!imageState.currentArrow) return;
            
            const dx = imageState.currentArrow.endX - imageState.currentArrow.startX;
            const dy = imageState.currentArrow.endY - imageState.currentArrow.startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 10) {
                imageState.arrows.push({ ...imageState.currentArrow });
                imageState.currentArrow = null;
                redrawCanvas();
                saveToHistory();
                selectObject(imageState.arrows[imageState.arrows.length - 1], false);
            } else {
                imageState.currentArrow = null;
                redrawCanvas();
            }
        }

        // --- Shape ---
        function startShape(x, y) {
            imageState.currentShape = {
                ...toolSettings.shape,
                startX: x, startY: y, endX: x, endY: y,
                id: Date.now()
            };
        }

        function updateShape(x, y) {
            if (!imageState.currentShape) return;
            
            imageState.currentShape.endX = x;
            imageState.currentShape.endY = y;
            
            redrawCanvas();
            
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.setLineDash([5, 5]);
            drawShape(imageState.currentShape);
            ctx.restore();
        }

        function finishShape() {
            if (!imageState.currentShape) return;
            
            const width = Math.abs(imageState.currentShape.endX - imageState.currentShape.startX);
            const height = Math.abs(imageState.currentShape.endY - imageState.currentShape.startY);
            
            if (width > 5 || height > 5) {
                imageState.shapes.push({ ...imageState.currentShape });
                imageState.currentShape = null;
                redrawCanvas();
                saveToHistory();
                selectObject(imageState.shapes[imageState.shapes.length - 1], false);
            } else {
                imageState.currentShape = null;
                redrawCanvas();
            }
        }
        
        // --- Text ---
        function addTextAtPosition(x, y) {
            if (!canvas || !ctx) {
                return;
            }
            
            appState.textClickPosition = { x, y };
            
            // Show text properties when text tool is used
            showToolProperties('text');
            
            // Verificar que todos los elementos existan
            if (!domElements.textInput || !domElements.textModal) {
                return;
            }
            
            domElements.textInput.value = '';
            if (domElements.textFontModal) domElements.textFontModal.value = toolSettings.text.font;
            if (domElements.textSizeModal) domElements.textSizeModal.value = toolSettings.text.size;
            if (domElements.textSizeModalValue) domElements.textSizeModalValue.textContent = `${toolSettings.text.size}px`;
            if (domElements.textColorPickerModal) domElements.textColorPickerModal.value = toolSettings.currentColor;
            
            document.querySelectorAll('#textModal .text-style-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('#textModal .text-align-btn').forEach(btn => btn.classList.remove('active'));
            
            if (toolSettings.text.style.includes('bold') && domElements.textBoldModal) domElements.textBoldModal.classList.add('active');
            if (toolSettings.text.style.includes('italic') && domElements.textItalicModal) domElements.textItalicModal.classList.add('active');
            if (toolSettings.text.style.includes('underline') && domElements.textUnderlineModal) domElements.textUnderlineModal.classList.add('active');
            
            const alignBtns = document.querySelectorAll('#textModal .text-align-btn');
            if (toolSettings.text.align === 'left' && alignBtns[0]) alignBtns[0].classList.add('active');
            else if (toolSettings.text.align === 'center' && alignBtns[1]) alignBtns[1].classList.add('active');
            else if (toolSettings.text.align === 'right' && alignBtns[2]) alignBtns[2].classList.add('active');
            
            domElements.textModal.style.display = 'flex';
            setTimeout(() => {
                if (domElements.textInput) {
                    domElements.textInput.focus();
                    updateTextPreview();
                }
            }, 100);
        }
        
        function confirmAddText() {
            const text = domElements.textInput.value.trim();
            if (!text) return;

            updateTextPreview(); 
            
            if (appState.editingTextElement) {
                const textElement = appState.editingTextElement;
                textElement.text = text;
                textElement.size = toolSettings.text.size;
                textElement.font = toolSettings.text.font;
                textElement.style = toolSettings.text.style;
                textElement.align = toolSettings.text.align;
                textElement.color = toolSettings.currentColor;
                
                calculateTextDimensions(textElement);
                selectObject(textElement, true);
                appState.editingTextElement = null;
            } else {
                const textElement = {
                    text,
                    x: appState.textClickPosition.x,
                    y: appState.textClickPosition.y,
                    size: toolSettings.text.size,
                    font: toolSettings.text.font,
                    style: toolSettings.text.style,
                    align: toolSettings.text.align,
                    color: toolSettings.currentColor,
                    id: Date.now()
                };
                
                calculateTextDimensions(textElement);
                imageState.textElements.push(textElement);
                selectObject(textElement, true);
            }
            
            redrawCanvas();
            closeTextModal();
            saveToHistory();
        }
        
        function calculateTextDimensions(textElement) {
            ctx.save();
            let fontStyle = '';
            if (textElement.style.includes('bold')) fontStyle += 'bold ';
            if (textElement.style.includes('italic')) fontStyle += 'italic ';
            ctx.font = `${fontStyle}${textElement.size}px "${textElement.font}"`;
            
            const lines = textElement.text.split('\n');
            const lineHeight = textElement.size * 1.2;
            let maxWidth = 0;
            lines.forEach(line => {
                maxWidth = Math.max(maxWidth, ctx.measureText(line).width);
            });
            
            textElement.width = maxWidth;
            textElement.height = lines.length * lineHeight;
            ctx.restore();
        }

        // =================================================================================
        // SECTION: CANVAS DRAWING & RENDERING
        // =================================================================================
        
        function drawArrow(arrow) {
            ctx.save();
            ctx.globalAlpha = arrow.opacity / 100;
            ctx.strokeStyle = arrow.color;
            ctx.fillStyle = arrow.color;
            ctx.lineWidth = arrow.thickness;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const dx = arrow.endX - arrow.startX;
            const dy = arrow.endY - arrow.startY;
            const angle = Math.atan2(dy, dx);

            const arrowDrawers = {
                simple: drawSimpleArrow,
                double: drawDoubleArrow,
                curved: drawCurvedArrow,
                thick: drawThickArrow,
                dashed: drawDashedArrow,
                outline: drawOutlineArrow,
            };

            if (arrowDrawers[arrow.type]) {
                arrowDrawers[arrow.type](ctx, arrow, angle);
            }
            
            ctx.restore();
        }
        
        function drawShape(shape) {
            ctx.save();
            ctx.globalAlpha = shape.opacity / 100;
            
            const x = Math.min(shape.startX, shape.endX);
            const y = Math.min(shape.startY, shape.endY);
            const width = Math.abs(shape.endX - shape.startX);
            const height = Math.abs(shape.endY - shape.startY);
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            const radius = Math.min(width, height) / 2;
            
            ctx.lineWidth = shape.strokeWidth;
            ctx.strokeStyle = shape.strokeColor;
            ctx.fillStyle = shape.fillColor;
            
            const shapeDrawers = {
                circle: () => drawCircle(ctx, centerX, centerY, radius, shape),
                square: () => { const size = Math.min(width, height); drawRectangle(ctx, centerX - size / 2, centerY - size / 2, size, size, shape); },
                rectangle: () => drawRectangle(ctx, x, y, width, height, shape),
                ellipse: () => drawEllipse(ctx, centerX, centerY, width / 2, height / 2, shape),
                line: () => drawLine(ctx, shape.startX, shape.startY, shape.endX, shape.endY, shape),
                diagonal: () => drawLine(ctx, shape.startX, shape.startY, shape.endX, shape.endY, shape),
                triangle: () => drawPolygon(ctx, centerX, centerY, radius, 3, shape),
                pentagon: () => drawPolygon(ctx, centerX, centerY, radius, 5, shape),
                hexagon: () => drawPolygon(ctx, centerX, centerY, radius, 6, shape),
                octagon: () => drawPolygon(ctx, centerX, centerY, radius, 8, shape),
                star: () => drawStar(ctx, centerX, centerY, radius, shape.starSpikes, shape.starDepth, shape),
                diamond: () => drawDiamond(ctx, centerX, centerY, width / 2, height / 2, shape),
                trapezoid: () => drawTrapezoid(ctx, x, y, width, height, shape),
                parallelogram: () => drawParallelogram(ctx, x, y, width, height, shape),
                heart: () => drawHeart(ctx, centerX, centerY, radius, shape),
                cross: () => drawCross(ctx, centerX, centerY, width / 2, height / 2, shape),
                cloud: () => drawCloud(ctx, centerX, centerY, width / 2, height / 2, shape),
                lightning: () => drawLightning(ctx, x, y, width, height, shape),
                spiral: () => drawSpiral(ctx, centerX, centerY, radius, shape.spiralTurns, shape),
                arc: () => drawArc(ctx, centerX, centerY, radius, shape.arcStartAngle, shape.arcEndAngle, shape),
                sector: () => drawSector(ctx, centerX, centerY, radius, shape.arcStartAngle, shape.arcEndAngle, shape),
                gear: () => drawGear(ctx, centerX, centerY, radius, shape.gearTeeth, shape),
            };

            if (shapeDrawers[shape.type]) {
                shapeDrawers[shape.type]();
            }
            
            ctx.restore();
        }

        function drawTextElement(textElement) {
            ctx.save();
            let fontStyle = '';
            if (textElement.style.includes('bold')) fontStyle += 'bold ';
            if (textElement.style.includes('italic')) fontStyle += 'italic ';
            
            ctx.font = `${fontStyle}${textElement.size}px "${textElement.font}"`;
            ctx.fillStyle = textElement.color;
            ctx.textAlign = textElement.align;
            ctx.textBaseline = 'middle';
            
            const lines = textElement.text.split('\n');
            const lineHeight = textElement.size * 1.2;
            
            lines.forEach((line, index) => {
                const yPos = textElement.y + (index - (lines.length - 1) / 2) * lineHeight;
                ctx.fillText(line, textElement.x, yPos);
                
                if (textElement.style.includes('underline')) {
                    const lineWidth = ctx.measureText(line).width;
                    let underlineX = textElement.x;
                    if (textElement.align === 'center') underlineX -= lineWidth / 2;
                    else if (textElement.align === 'right') underlineX -= lineWidth;
                    
                    ctx.beginPath();
                    ctx.moveTo(underlineX, yPos + textElement.size / 8);
                    ctx.lineTo(underlineX + lineWidth, yPos + textElement.size / 8);
                    ctx.strokeStyle = textElement.color;
                    ctx.lineWidth = Math.max(1, textElement.size / 20);
                    ctx.stroke();
                }
            });
            
            ctx.restore();
        }
        
        function drawSimpleArrow(context, arrow, angle) {
            context.beginPath();
            context.moveTo(arrow.startX, arrow.startY);
            context.lineTo(arrow.endX, arrow.endY);
            context.stroke();
            drawArrowHead(context, arrow.endX, arrow.endY, angle, arrow.headSize);
        }
        
        function drawDoubleArrow(context, arrow, angle) {
            context.beginPath();
            context.moveTo(arrow.startX, arrow.startY);
            context.lineTo(arrow.endX, arrow.endY);
            context.stroke();
            drawArrowHead(context, arrow.endX, arrow.endY, angle, arrow.headSize);
            drawArrowHead(context, arrow.startX, arrow.startY, angle + Math.PI, arrow.headSize);
        }

        function drawCurvedArrow(context, arrow) {
            const controlX = arrow.controlX;
            const controlY = arrow.controlY;
            if (typeof controlX !== 'number' || typeof controlY !== 'number') return;
        
            context.beginPath();
            context.moveTo(arrow.startX, arrow.startY);
            context.quadraticCurveTo(controlX, controlY, arrow.endX, arrow.endY);
            context.stroke();
            
            const headAngle = Math.atan2(arrow.endY - controlY, arrow.endX - controlX);
            drawArrowHead(context, arrow.endX, arrow.endY, headAngle, arrow.headSize);
        }
        
        function drawThickArrow(context, arrow, angle) {
            const thickWidth = arrow.thickness * 2;
            context.lineWidth = thickWidth;
            context.lineCap = 'round';
            context.lineJoin = 'round';
            
            context.beginPath();
            context.moveTo(arrow.startX, arrow.startY);
            context.lineTo(arrow.endX, arrow.endY);
            context.stroke();
            
            drawArrowHead(context, arrow.endX, arrow.endY, angle, arrow.headSize * 1.5);
        }
        
        function drawDashedArrow(context, arrow, angle) {
            context.setLineDash([10, 5]);
            context.beginPath();
            context.moveTo(arrow.startX, arrow.startY);
            context.lineTo(arrow.endX, arrow.endY);
            context.stroke();
            context.setLineDash([]);
            
            drawArrowHead(context, arrow.endX, arrow.endY, angle, arrow.headSize);
        }
        
        function drawOutlineArrow(context, arrow, angle) {
            context.lineWidth = arrow.thickness + 2;
            context.strokeStyle = '#FFFFFF';
            context.beginPath();
            context.moveTo(arrow.startX, arrow.startY);
            context.lineTo(arrow.endX, arrow.endY);
            context.stroke();
            
            context.lineWidth = arrow.thickness;
            context.strokeStyle = arrow.color;
            context.beginPath();
            context.moveTo(arrow.startX, arrow.startY);
            context.lineTo(arrow.endX, arrow.endY);
            context.stroke();
            
            drawArrowHead(context, arrow.endX, arrow.endY, angle, arrow.headSize);
        }
        
        function drawArrowHead(context, x, y, angle, headSize) {
            const headAngle = Math.PI / 6;
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x - headSize * Math.cos(angle - headAngle), y - headSize * Math.sin(angle - headAngle));
            context.moveTo(x, y);
            context.lineTo(x - headSize * Math.cos(angle + headAngle), y - headSize * Math.sin(angle + headAngle));
            context.stroke();
        }
        
        function drawCircle(context, x, y, radius, shape) { context.beginPath(); context.arc(x, y, radius, 0, 2 * Math.PI); applyShapeStyle(context, shape); }
        function drawRectangle(context, x, y, width, height, shape) { context.beginPath(); context.rect(x, y, width, height); applyShapeStyle(context, shape); }
        function drawEllipse(context, x, y, radiusX, radiusY, shape) { context.beginPath(); context.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI); applyShapeStyle(context, shape); }
        function drawLine(context, x1, y1, x2, y2, shape) { context.beginPath(); context.moveTo(x1, y1); context.lineTo(x2, y2); context.stroke(); }
        function drawPolygon(context, x, y, radius, sides, shape) { context.beginPath(); for (let i = 0; i < sides; i++) { const angle = (i * 2 * Math.PI / sides) - Math.PI / 2; const px = x + radius * Math.cos(angle); const py = y + radius * Math.sin(angle); if (i === 0) context.moveTo(px, py); else context.lineTo(px, py); } context.closePath(); applyShapeStyle(context, shape); }
        function drawStar(context, x, y, radius, spikes, depth, shape) {
            context.beginPath();
            const outerRadius = radius;
            const innerRadius = radius * depth;
            
            for (let i = 0; i < spikes * 2; i++) {
                const angle = (i * Math.PI) / spikes - Math.PI / 2;
                const currentRadius = i % 2 === 0 ? outerRadius : innerRadius;
                const px = x + currentRadius * Math.cos(angle);
                const py = y + currentRadius * Math.sin(angle);
                
                if (i === 0) context.moveTo(px, py);
                else context.lineTo(px, py);
            }
            context.closePath();
            applyShapeStyle(context, shape);
        }

        function drawDiamond(context, x, y, radiusX, radiusY, shape) {
            context.beginPath();
            context.moveTo(x, y - radiusY);
            context.lineTo(x + radiusX, y);
            context.lineTo(x, y + radiusY);
            context.lineTo(x - radiusX, y);
            context.closePath();
            applyShapeStyle(context, shape);
        }

        function drawTrapezoid(context, x, y, width, height, shape) {
            context.beginPath();
            const topWidth = width * 0.7;
            const offset = (width - topWidth) / 2;
            context.moveTo(x + offset, y);
            context.lineTo(x + width - offset, y);
            context.lineTo(x + width, y + height);
            context.lineTo(x, y + height);
            context.closePath();
            applyShapeStyle(context, shape);
        }

        function drawParallelogram(context, x, y, width, height, shape) {
            context.beginPath();
            const offset = width * 0.2;
            context.moveTo(x + offset, y);
            context.lineTo(x + width, y);
            context.lineTo(x + width - offset, y + height);
            context.lineTo(x, y + height);
            context.closePath();
            applyShapeStyle(context, shape);
        }

        function drawHeart(context, x, y, radius, shape) {
            context.beginPath();
            const topCurveHeight = radius * 0.3;
            context.moveTo(x, y + topCurveHeight);
            
            context.bezierCurveTo(x, y, x - radius / 2, y, x - radius / 2, y + topCurveHeight);
            context.bezierCurveTo(x - radius / 2, y + (radius + topCurveHeight) / 2, x, y + (radius + topCurveHeight) / 2, x, y + radius);
            
            context.bezierCurveTo(x, y + (radius + topCurveHeight) / 2, x + radius / 2, y + (radius + topCurveHeight) / 2, x + radius / 2, y + topCurveHeight);
            context.bezierCurveTo(x + radius / 2, y, x, y, x, y + topCurveHeight);
            
            applyShapeStyle(context, shape);
        }

        function drawCross(context, x, y, radiusX, radiusY, shape) {
            context.beginPath();
            const thickness = Math.min(radiusX, radiusY) * 0.3;
            
            context.rect(x - thickness / 2, y - radiusY, thickness, radiusY * 2);
            context.rect(x - radiusX, y - thickness / 2, radiusX * 2, thickness);
            
            applyShapeStyle(context, shape);
        }

        function drawCloud(context, x, y, radiusX, radiusY, shape) {
            context.beginPath();
            const r1 = radiusY * 0.5;
            const r2 = radiusY * 0.7;
            const r3 = radiusY * 0.4;
            const r4 = radiusY * 0.6;
            
            context.arc(x - radiusX * 0.5, y, r1, 0, Math.PI * 2);
            context.arc(x - radiusX * 0.2, y - radiusY * 0.3, r2, 0, Math.PI * 2);
            context.arc(x + radiusX * 0.2, y - radiusY * 0.2, r3, 0, Math.PI * 2);
            context.arc(x + radiusX * 0.5, y, r4, 0, Math.PI * 2);
            context.arc(x, y + radiusY * 0.2, radiusY * 0.8, 0, Math.PI * 2);
            
            applyShapeStyle(context, shape);
        }

        function drawLightning(context, x, y, width, height, shape) {
            context.beginPath();
            context.moveTo(x + width * 0.2, y);
            context.lineTo(x + width * 0.8, y);
            context.lineTo(x + width * 0.4, y + height * 0.4);
            context.lineTo(x + width * 0.7, y + height * 0.4);
            context.lineTo(x + width * 0.1, y + height);
            context.lineTo(x + width * 0.5, y + height * 0.6);
            context.lineTo(x + width * 0.2, y + height * 0.6);
            context.closePath();
            applyShapeStyle(context, shape);
        }

        function drawSpiral(context, x, y, radius, turns, shape) {
            context.beginPath();
            const totalAngle = turns * 2 * Math.PI;
            const steps = 100;
            
            for (let i = 0; i <= steps; i++) {
                const angle = (i / steps) * totalAngle;
                const currentRadius = (i / steps) * radius;
                const px = x + currentRadius * Math.cos(angle);
                const py = y + currentRadius * Math.sin(angle);
                
                if (i === 0) context.moveTo(px, py);
                else context.lineTo(px, py);
            }
            context.stroke();
        }

        function drawArc(context, x, y, radius, start, end, shape) {
            context.beginPath();
            const startAngle = (start * Math.PI) / 180;
            const endAngle = (end * Math.PI) / 180;
            context.arc(x, y, radius, startAngle, endAngle);
            context.stroke();
        }

        function drawSector(context, x, y, radius, start, end, shape) {
            context.beginPath();
            const startAngle = (start * Math.PI) / 180;
            const endAngle = (end * Math.PI) / 180;
            context.moveTo(x, y);
            context.arc(x, y, radius, startAngle, endAngle);
            context.closePath();
            applyShapeStyle(context, shape);
        }

        function drawGear(context, x, y, radius, teeth, shape) {
            context.beginPath();
            const outerRadius = radius;
            const innerRadius = radius * 0.7;
            const toothAngle = (2 * Math.PI) / teeth;
            
            for (let i = 0; i < teeth; i++) {
                const angle1 = i * toothAngle;
                const angle2 = angle1 + toothAngle * 0.4;
                const angle3 = angle1 + toothAngle * 0.6;
                const angle4 = angle1 + toothAngle;
                
                const x1 = x + outerRadius * Math.cos(angle1);
                const y1 = y + outerRadius * Math.sin(angle1);
                const x2 = x + outerRadius * Math.cos(angle2);
                const y2 = y + outerRadius * Math.sin(angle2);
                const x3 = x + outerRadius * Math.cos(angle3);
                const y3 = y + outerRadius * Math.sin(angle3);
                const x4 = x + outerRadius * Math.cos(angle4);
                const y4 = y + outerRadius * Math.sin(angle4);
                
                const ix1 = x + innerRadius * Math.cos(angle2);
                const iy1 = y + innerRadius * Math.sin(angle2);
                const ix2 = x + innerRadius * Math.cos(angle3);
                const iy2 = y + innerRadius * Math.sin(angle3);
                
                if (i === 0) context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineTo(ix1, iy1);
                context.lineTo(ix2, iy2);
                context.lineTo(x3, y3);
                context.lineTo(x4, y4);
            }
            context.closePath();
            applyShapeStyle(context, shape);
        }
        
        function applyShapeStyle(context, shape) {
            if (shape.style === 'fill' || shape.style === 'both') context.fill();
            if (shape.style === 'stroke' || shape.style === 'both') context.stroke();
        }

        // =================================================================================
        // SECTION: UI & PANEL MANAGEMENT
        // =================================================================================

        function updateSliderUI(sliderId, value) {
            const valueSpan = document.getElementById(`${sliderId}Value`);
            if (valueSpan) {
                let displayValue = value;
                if (sliderId === 'exportQuality') {
                    displayValue = `${Math.round(value * 100)}%`;
                } else if (sliderId.endsWith('px')) {
                    displayValue = `${value}px`;
                }
                valueSpan.textContent = displayValue;
            }
        }

        function updateCanvasDisplaySize() {
            if (!canvas) return;
            
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = canvas.width / dpr;
            const displayHeight = canvas.height / dpr;
            
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            domElements.canvasWidth.value = displayWidth;
            domElements.canvasHeight.value = displayHeight;
        }
        
        function updateToolPropertiesPanelVisibility() {
            document.querySelectorAll('#toolProperties > .control-group').forEach(el => el.style.display = 'none');
            
            const toolToPanelMap = {
                'brush': 'brushProperties',
                'eraser': 'brushProperties',
                'arrow': 'arrowProperties',
                'text': 'textProperties',
                'shapes': 'shapeProperties'
            };
            const panelId = toolToPanelMap[appState.currentTool];
            if (panelId) {
                domElements[panelId].style.display = 'block';
                if(panelId === 'arrowProperties') initializeArrowProperties();
                if(panelId === 'textProperties') initializeTextProperties();
                if(panelId === 'shapeProperties') initializeShapeProperties();
            }
        }
        
        function closeAllFloatingPanels(exceptPanelId = null) {
            document.querySelectorAll('.floating-panel').forEach(panel => {
                if (exceptPanelId && panel.id === exceptPanelId) return;
                panel.classList.remove('show');
                panel.style.display = 'none';
            });
            
            // Solo remover 'active' de botones espec√≠ficos que abren paneles flotantes
            document.querySelectorAll('.tool-btn').forEach(btn => {
                const tool = btn.dataset.tool;
                const isFloatingPanelTool = ['palette', 'thickness'].includes(tool);
                const isProtected = (exceptPanelId === 'colorPalettePanel' && tool === 'palette') ||
                                    (exceptPanelId === 'thicknessPanel' && tool === 'thickness');
                
                // Solo remover 'active' si es un tool de panel flotante y no est√° protegido
                if (isFloatingPanelTool && !isProtected) {
                    btn.classList.remove('active');
                }
            });
        }
        
        function toggleFloatingPanel(panelId, anchorTool) {
            const panel = domElements[panelId];
            const anchor = document.querySelector(`[data-tool="${anchorTool}"]`);
            
            if (!panel) return;
            
            const isVisible = panel.classList.contains('show');
            
            if (isVisible) {
                panel.classList.remove('show');
                panel.style.display = 'none';
                if (anchor && ['palette', 'thickness'].includes(anchorTool)) {
                    anchor.classList.remove('active');
                }
            } else {
                closeAllFloatingPanels(panelId);
                
                if (anchor) {
                    const anchorRect = anchor.getBoundingClientRect();
                    panel.style.left = `${anchorRect.right + 10}px`;
                    panel.style.top = panelId === 'thicknessPanel' ? `${anchorRect.top - 45}px` : `${anchorRect.top}px`;
                    
                    if (['palette', 'thickness'].includes(anchorTool)) {
                        anchor.classList.add('active');
                    }
                } else {
                    panel.style.left = '50%';
                    panel.style.top = '50%';
                    panel.style.transform = 'translate(-50%, -50%)';
                }
                
                panel.style.display = 'block';
                panel.classList.add('show');
            }
        }

        function toggleColorPalette() { toggleFloatingPanel('colorPalettePanel', 'palette'); }
        function toggleThicknessPanel() { toggleFloatingPanel('thicknessPanel', 'thickness'); }
        function activateShapesTool() {
            if (appState.currentTool === 'shapes') {
                selectObject(null);
                return;
            }
            
            selectTool('shapes');
            
            if (!toolSettings.shape.type) {
                toolSettings.shape.type = 'rectangle';
            }
            
            // Show shape properties when shapes tool is activated
            showToolProperties('shape');
            
            setTimeout(updateAllToolPropertiesUI, 50);
        }
        
        function selectQuickColor(color) {
            toolSettings.currentColor = color;
            
            switch(appState.currentTool) {
                case 'brush': toolSettings.brush.color = color; break;
                case 'arrow': toolSettings.arrow.color = color; break;
                case 'text': toolSettings.text.color = color; break;
                case 'shapes': toolSettings.shape.fillColor = color; break;
            }
            
            updateAllToolPropertiesUI();
        }

        function selectThickness(thickness, updateSlider = false) {
            toolSettings.globalThickness = parseInt(thickness);
            
            switch(appState.currentTool) {
                case 'brush': toolSettings.brush.size = parseInt(thickness); break;
                case 'arrow': toolSettings.arrow.thickness = parseInt(thickness); break;
                case 'shapes': toolSettings.shape.strokeWidth = parseInt(thickness); break;
            }
            
            updateAllToolPropertiesUI();
            
            if (updateSlider) {
                domElements.customThicknessValue.textContent = thickness + 'px';
            }
        }
        
        function updateBrushSize(size) { selectThickness(size); }
        function updateBrushHardness(hardness) { toolSettings.brush.hardness = parseInt(hardness); updateAllToolPropertiesUI(); }
        function updateBrushOpacity(opacity) { toolSettings.brush.opacity = parseInt(opacity); updateAllToolPropertiesUI(); }
        function updateBrushColor(color) { selectQuickColor(color); }

        function updateArrowType(type) { 
            toolSettings.arrow.type = type; 
            updateAllToolPropertiesUI();
        }
        function updateArrowThickness(thickness) { 
            toolSettings.arrow.thickness = parseInt(thickness); 
            toolSettings.globalThickness = parseInt(thickness);
            updateAllToolPropertiesUI(); 
        }
        function updateArrowHeadSize(size) { 
            toolSettings.arrow.headSize = parseInt(size); 
            updateAllToolPropertiesUI(); 
        }
        function updateArrowOpacity(opacity) { 
            toolSettings.arrow.opacity = parseInt(opacity); 
            updateAllToolPropertiesUI(); 
        }
        function updateArrowColor(color) { 
            toolSettings.arrow.color = color;
            toolSettings.currentColor = color;
            updateAllToolPropertiesUI(); 
        }

        function updateShapeType(v){
            toolSettings.shape.type = v;
            document.querySelectorAll('#shapeSpecialControls > div').forEach(div => div.style.display = 'none');
            
            const specialControls = {
                star: 'starControls',
                spiral: 'spiralControls',
                arc: 'arcControls',
                sector: 'arcControls',
                gear: 'gearControls'
            };
            if (specialControls[v]) {
                document.getElementById(specialControls[v]).style.display = 'block';
            }
        }
        
        function updateShapeStyle(v){ toolSettings.shape.style = v; }
        function updateShapeStrokeWidth(v){ toolSettings.shape.strokeWidth = parseInt(v); domElements.shapeStrokeWidthValue.textContent = v; }
        function updateShapeFillColor(v){ toolSettings.shape.fillColor = v; }
        function updateShapeStrokeColor(v){ toolSettings.shape.strokeColor = v; }
        function updateShapeOpacity(v){ toolSettings.shape.opacity = parseInt(v); domElements.shapeOpacityValue.textContent = `${v}%`; }
        function updateStarSpikes(v){ toolSettings.shape.starSpikes = parseInt(v); domElements.starSpikesValue.textContent = v; }
        function updateStarDepth(v){ toolSettings.shape.starDepth = parseFloat(v); domElements.starDepthValue.textContent = v; }
        function updateSpiralTurns(v){ toolSettings.shape.spiralTurns = parseInt(v); domElements.spiralTurnsValue.textContent = v; }
        function updateArcStartAngle(v){ toolSettings.shape.arcStartAngle = parseInt(v); domElements.arcStartAngleValue.textContent = `${v}¬∞`; }
        function updateArcEndAngle(v){ toolSettings.shape.arcEndAngle = parseInt(v); domElements.arcEndAngleValue.textContent = `${v}¬∞`; }
        function updateGearTeeth(v){ toolSettings.shape.gearTeeth = parseInt(v); domElements.gearTeethValue.textContent = v; }
        
        function updateAllToolPropertiesUI() {
            updateSliderUI('brushSize', toolSettings.brush.size);
            updateSliderUI('brushHardness', toolSettings.brush.hardness);
            updateSliderUI('brushOpacity', toolSettings.brush.opacity);
            
            updateSliderUI('arrowThickness', toolSettings.arrow.thickness);
            updateSliderUI('arrowHeadSize', toolSettings.arrow.headSize);
            updateSliderUI('arrowOpacity', toolSettings.arrow.opacity);
            
            updateSliderUI('textSize', toolSettings.text.size);
            
            updateSliderUI('shapeStrokeWidth', toolSettings.shape.strokeWidth);
            updateSliderUI('shapeOpacity', toolSettings.shape.opacity);
            
            ['brushColor', 'arrowColor', 'textColorPicker', 'shapeFillColor', 'shapeStrokeColor'].forEach(id => {
                const input = document.getElementById(id);
                if (input) input.value = toolSettings.currentColor;
            });
            
            const arrowTypeSelect = document.getElementById('arrowType');
            if (arrowTypeSelect) {
                arrowTypeSelect.value = toolSettings.arrow.type;
            }
            
            const textFontSelect = document.getElementById('textFont');
            if (textFontSelect) textFontSelect.value = toolSettings.text.font;
            
            const shapeTypeSelect = document.getElementById('shapeType');
            if (shapeTypeSelect) shapeTypeSelect.value = toolSettings.shape.type;
            
            const shapeStyleSelect = document.getElementById('shapeStyle');
            if (shapeStyleSelect) shapeStyleSelect.value = toolSettings.shape.style;
        }

        function updateCursor() {
            if (!canvas) return;
            canvas.style.cursor = getCursorForTool(appState.currentTool);
        }

        function getCanvasMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = (canvas.width / (window.devicePixelRatio || 1)) / rect.width;
            const scaleY = (canvas.height / (window.devicePixelRatio || 1)) / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }
        function moveSelectedObject(x, y) {
if (!imageState.selectedObject) return;
            
            const obj = imageState.selectedObject;
            const newX = x - appState.dragOffset.x;
            const newY = y - appState.dragOffset.y;
            
            if (obj.text) {
                obj.x = newX;
                obj.y = newY;
} else if (obj.startX !== undefined && obj.startY !== undefined) {
                const width = obj.endX - obj.startX;
                const height = obj.endY - obj.startY;
                
                obj.startX = newX - width / 2;
                obj.startY = newY - height / 2;
                obj.endX = newX + width / 2;
                obj.endY = newY + height / 2;
                
                if (obj.controlX !== undefined && obj.controlY !== undefined) {
                    obj.controlX = newX;
                    obj.controlY = newY;
                }
            }
            
            redrawCanvas();
            showHandlesForObject(obj);
        }

        function handleHandleMouseDown(e, obj, handle) {
            e.preventDefault();
            appState.isResizing = true;
            appState.currentResizeHandle = handle;
            appState.resizeObject = obj;
            appState.dragStart = getCanvasMousePos(e);
            
            document.addEventListener('mousemove', handleHandleMouseMove);
            document.addEventListener('mouseup', handleHandleMouseUp);
        }

        function handleHandleMouseMove(e) {
            if (!appState.isResizing || !appState.resizeObject) return;
            
            const pos = getCanvasMousePos(e);
            const obj = appState.resizeObject;
            const handle = appState.currentResizeHandle;
            
            if (obj.text) {
                if (handle === 'resize-nw' || handle === 'resize-se') {
                    const deltaX = pos.x - appState.dragStart.x;
                    const deltaY = pos.y - appState.dragStart.y;
                    const scale = Math.max(0.5, 1 + (deltaX + deltaY) / 200);
                    obj.size = Math.max(10, Math.min(100, obj.size * scale));
                    appState.dragStart = pos;
                }
            } else if (obj.startX !== undefined) {
                if (handle === 'start') {
                    obj.startX = pos.x;
                    obj.startY = pos.y;
                } else if (handle === 'end') {
                    obj.endX = pos.x;
                    obj.endY = pos.y;
                } else if (handle === 'control' && obj.controlX !== undefined) {
                    obj.controlX = pos.x;
                    obj.controlY = pos.y;
                } else if (handle.startsWith('resize-') || handle.includes('w') || handle.includes('e') || handle.includes('n') || handle.includes('s')) {
                    const left = Math.min(obj.startX, obj.endX);
                    const right = Math.max(obj.startX, obj.endX);
                    const top = Math.min(obj.startY, obj.endY);
                    const bottom = Math.max(obj.startY, obj.endY);
                    
                    if (handle.includes('n')) { obj.startY = pos.y; obj.endY = bottom; }
                    if (handle.includes('s')) { obj.startY = top; obj.endY = pos.y; }
                    if (handle.includes('w')) { obj.startX = pos.x; obj.endX = right; }
                    if (handle.includes('e')) { obj.startX = left; obj.endX = pos.x; }
                }
            }
            redrawCanvas();
            showHandlesForObject(obj);
        }

        function handleHandleMouseUp(e) {
            if (appState.isResizing) {
                saveToHistory();
            }
            
            appState.isResizing = false;
            appState.resizeObject = null;
            appState.currentResizeHandle = null;
            
            document.removeEventListener('mousemove', handleHandleMouseMove);
            document.removeEventListener('mouseup', handleHandleMouseUp);
        }
        function findObjectAtPoint(x, y) {
            const tolerance = 15;
            
            for (let i = imageState.textElements.length - 1; i >= 0; i--) {
                const text = imageState.textElements[i];
                const inBounds = isPointInTextBounds(x, y, text, tolerance);
                if (inBounds) {
                    const handle = getTextHandle(x, y, text);
                    return { object: text, handle: handle };
                }
            }
            
            for (let i = imageState.arrows.length - 1; i >= 0; i--) {
                const arrow = imageState.arrows[i];
                if (isPointNearArrow(x, y, arrow, tolerance)) {
                    return { object: arrow, handle: getArrowHandle(x, y, arrow) };
                }
            }
            
            for (let i = imageState.shapes.length - 1; i >= 0; i--) {
                const shape = imageState.shapes[i];
                if (isPointInShape(x, y, shape, tolerance)) {
                    return { object: shape, handle: getShapeHandle(x, y, shape) };
                }
            }
            
            return { object: null, handle: null };
        }

        function selectObject(obj, autoSelectTool = true) {
            imageState.selectedObject = obj;
            clearAllHandles();
            
            if (obj) {
                const creationTools = ['shapes', 'arrow', 'text', 'brush', 'eraser'];
                const shouldKeepCurrentTool = creationTools.includes(appState.currentTool) && !autoSelectTool;
                
                if (!shouldKeepCurrentTool && appState.currentTool !== 'select') {
                    selectTool('select');
                }
                
                showHandlesForObject(obj);
                updateToolPropertiesPanelVisibility();
            }
        }

        function clearAllHandles() {
            document.querySelectorAll('.arrow-handle, .text-handle, .shape-handle, .text-selection-outline').forEach(el => el.remove());
            imageState.activeHandles = [];
        }

        function startSelection(x, y) {
            imageState.selectionActive = true;
            imageState.selectionRect = { x, y, width: 0, height: 0 };

            if (domElements.selectionOverlay) {
                domElements.selectionOverlay.style.display = 'block';
                domElements.selectionOverlay.style.left = `${x}px`;
                domElements.selectionOverlay.style.top = `${y}px`;
                domElements.selectionOverlay.style.width = '0px';
                domElements.selectionOverlay.style.height = '0px';
            }
        }

        function updateSelection(x, y) {
            if (!imageState.selectionActive) return;

            const startX = imageState.selectionRect.x;
            const startY = imageState.selectionRect.y;
            const width = Math.abs(x - startX);
            const height = Math.abs(y - startY);
            const left = Math.min(x, startX);
            const top = Math.min(y, startY);

            imageState.selectionRect = { x: left, y: top, width, height };

            if (domElements.selectionOverlay) {
                domElements.selectionOverlay.style.left = `${left}px`;
                domElements.selectionOverlay.style.top = `${top}px`;
                domElements.selectionOverlay.style.width = `${width}px`;
                domElements.selectionOverlay.style.height = `${height}px`;
            }
        }

        function finishSelection() {
            imageState.selectionActive = false;

            if (appState.currentTool === 'crop' && imageState.selectionRect?.width > 10 && imageState.selectionRect?.height > 10) {
                // Sincronizar el rect√°ngulo de selecci√≥n con el de los puntos de control
                imageState.cropHandles.rect = { ...imageState.selectionRect };
                // Ocultar el overlay de selecci√≥n tradicional
                if (domElements.selectionOverlay) domElements.selectionOverlay.style.display = 'none';
                // Aplicar el recorte/extensi√≥n usando la l√≥gica de handles
                applyCropFromHandles();
                return; 
            }
            
            if (domElements.selectionOverlay) {
                domElements.selectionOverlay.style.display = 'none';
            }
        }

        function clearSelection() {
            imageState.selectionActive = false;
            imageState.selectedObject = null;
            clearAllHandles();
            
            if (domElements.selectionOverlay) {
                domElements.selectionOverlay.style.display = 'none';
            }
        }

        function deleteSelectedObject() {
            if (!imageState.selectedObject) return;
            
            const obj = imageState.selectedObject;
            
            const collections = [imageState.textElements, imageState.arrows, imageState.shapes];
            for (const collection of collections) {
                const index = collection.indexOf(obj);
                if (index > -1) {
                    collection.splice(index, 1);
                    break;
                }
            }
            
            clearSelection();
            redrawCanvas();
            saveToHistory();
        }

        function initializeArrowProperties(){
            document.getElementById('arrowType').value = toolSettings.arrow.type;
            document.getElementById('arrowThickness').value = toolSettings.globalThickness;
            document.getElementById('arrowThicknessValue').textContent = toolSettings.globalThickness;
            document.getElementById('arrowHeadSize').value = toolSettings.arrow.headSize;
            document.getElementById('arrowHeadSizeValue').textContent = toolSettings.arrow.headSize;
            document.getElementById('arrowColor').value = toolSettings.currentColor;
            document.getElementById('arrowOpacity').value = toolSettings.arrow.opacity;
            document.getElementById('arrowOpacityValue').textContent = `${toolSettings.arrow.opacity}%`;
        }

        function initializeTextProperties(){
            document.getElementById('textFont').value = toolSettings.text.font;
            document.getElementById('textSize').value = toolSettings.text.size;
            document.getElementById('textSizeValue').textContent = `${toolSettings.text.size}px`;
            document.getElementById('textColorPicker').value = toolSettings.currentColor;
            
            document.querySelectorAll('#textProperties .text-style-btn').forEach(btn => btn.classList.remove('active'));
            if (toolSettings.text.style.includes('bold')) document.getElementById('textBold')?.classList.add('active');
            if (toolSettings.text.style.includes('italic')) document.getElementById('textItalic')?.classList.add('active');
            if (toolSettings.text.style.includes('underline')) document.getElementById('textUnderline')?.classList.add('active');
        }

        function initializeShapeProperties(){
            document.getElementById('shapeType').value = toolSettings.shape.type;
            document.getElementById('shapeStyle').value = toolSettings.shape.style;
            document.getElementById('shapeStrokeWidth').value = toolSettings.shape.strokeWidth;
            document.getElementById('shapeStrokeWidthValue').textContent = toolSettings.shape.strokeWidth;
            document.getElementById('shapeFillColor').value = toolSettings.shape.fillColor;
            document.getElementById('shapeStrokeColor').value = toolSettings.shape.strokeColor;
            document.getElementById('shapeOpacity').value = toolSettings.shape.opacity;
            document.getElementById('shapeOpacityValue').textContent = `${toolSettings.shape.opacity}%`;
        }
        function updateAllFilterSlidersUI(){
            const filterControls = ['brightness', 'contrast', 'saturation', 'hue', 'exposure', 'temperature', 'blur', 'sharpen', 'vignette', 'grain'];
            
            filterControls.forEach(filter => {
                const slider = document.getElementById(filter);
                const valueDisplay = document.getElementById(filter + 'Value');
                
                if (slider && toolSettings.filters[filter] !== undefined) {
                    slider.value = toolSettings.filters[filter];
                    if (valueDisplay) {
                        valueDisplay.textContent = toolSettings.filters[filter];
                    }
                }
            });
        }

        function applyVignette(width, height) {
            const strength = toolSettings.filters.vignette / 100;
            if (strength === 0) return;

            const outerRadius = Math.sqrt(width*width + height*height) / 2;
            const gradient = ctx.createRadialGradient(
                width / 2, height / 2, outerRadius * (1 - strength),
                width / 2, height / 2, outerRadius
            );

            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.8)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        }

        function applyGrain(width, height) {
            const strength = toolSettings.filters.grain;
            if (strength === 0) return;

            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const grain = (Math.random() - 0.5) * strength;
                data[i] += grain;
                data[i+1] += grain;
                data[i+2] += grain;
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function applySharpen(width, height) {
            const strength = toolSettings.filters.sharpen / 100;
            if (strength === 0) return;

            const weights = [0, -1, 0, -1, 5, -1, 0, -1, 0];
            const W = Math.round(Math.sqrt(weights.length));
            const halfW = Math.floor(W / 2);

            const src = ctx.getImageData(0, 0, width, height);
            const dstData = new Uint8ClampedArray(src.data.length);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const sy = y;
                    const sx = x;
                    const dstOff = (y * width + x) * 4;
                    let r = 0, g = 0, b = 0;

                    for (let cy = 0; cy < W; cy++) {
                        for (let cx = 0; cx < W; cx++) {
                            const scy = Math.min(height - 1, Math.max(0, sy + cy - halfW));
                            const scx = Math.min(width - 1, Math.max(0, sx + cx - halfW));
                            const srcOff = (scy * width + scx) * 4;
                            const wt = weights[cy * W + cx];
                            r += src.data[srcOff] * wt;
                            g += src.data[srcOff + 1] * wt;
                            b += src.data[srcOff + 2] * wt;
                        }
                    }

                    dstData[dstOff] = r * strength + src.data[dstOff] * (1 - strength);
                    dstData[dstOff + 1] = g * strength + src.data[dstOff + 1] * (1 - strength);
                    dstData[dstOff + 2] = b * strength + src.data[dstOff + 2] * (1 - strength);
                    dstData[dstOff + 3] = src.data[dstOff + 3];
                }
            }

            ctx.putImageData(new ImageData(dstData, width, height), 0, 0);
        }

        function isPointInTextBounds(x, y, textElement, tolerance = 15) {
// Asegurar que las dimensiones esten calculadas
            if (!textElement.width || !textElement.height) {
                calculateTextDimensions(textElement);
            }
            
            // Si aun no tiene dimensiones, usar valores por defecto generosos
            if (!textElement.width || !textElement.height) {
                const defaultWidth = textElement.size * (textElement.text ? textElement.text.length : 10);
                const defaultHeight = textElement.size * 1.5;
                textElement.width = textElement.width || defaultWidth;
                textElement.height = textElement.height || defaultHeight;
            }
            
            let left, right;
            if (textElement.align === 'center') {
                left = textElement.x - textElement.width / 2;
                right = textElement.x + textElement.width / 2;
            } else if (textElement.align === 'right') {
                left = textElement.x - textElement.width;
                right = textElement.x;
            } else { 
                left = textElement.x;
                right = textElement.x + textElement.width;
            }
            
            const top = textElement.y - textElement.height / 2;
            const bottom = textElement.y + textElement.height / 2;
            
            // Tolerancia muy generosa - expandir area significativamente
            const expandedLeft = left - tolerance;
            const expandedRight = right + tolerance;
            const expandedTop = top - tolerance;
            const expandedBottom = bottom + tolerance;
            
            const result = x >= expandedLeft && 
                   x <= expandedRight && 
                   y >= expandedTop && 
                   y <= expandedBottom;
return result;
        }

        function isPointNearArrow(x, y, arrow, tolerance = 10) {
            const dist = distanceToLineSegment(x, y, arrow.startX, arrow.startY, arrow.endX, arrow.endY);
            return dist <= tolerance;
        }

        function isPointInShape(x, y, shape, tolerance = 10) {
            const minX = Math.min(shape.startX, shape.endX) - tolerance;
            const maxX = Math.max(shape.startX, shape.endX) + tolerance;
            const minY = Math.min(shape.startY, shape.endY) - tolerance;
            const maxY = Math.max(shape.startY, shape.endY) + tolerance;
            
            return x >= minX && x <= maxX && y >= minY && y <= maxY;
        }

        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSq = dx * dx + dy * dy;
            
            if (lengthSq === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            
            return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
        }

        function getTextHandle(x, y, textElement) {
if (!textElement.width || !textElement.height) {
return null;
            }
            
            const handleSize = 12;
            let left, right, top, bottom, centerX;
            
            if (textElement.align === 'center') {
                left = textElement.x - textElement.width / 2;
                right = textElement.x + textElement.width / 2;
                centerX = textElement.x;
            } else if (textElement.align === 'right') {
                left = textElement.x - textElement.width;
                right = textElement.x;
                centerX = textElement.x - textElement.width / 2;
            } else {
                left = textElement.x;
                right = textElement.x + textElement.width;
                centerX = textElement.x + textElement.width / 2;
            }
            
            top = textElement.y - textElement.height / 2;
            bottom = textElement.y + textElement.height / 2;
            const centerY = textElement.y;
            
            let handle = null;
            if (Math.abs(x - right) < handleSize && Math.abs(y - top) < handleSize) handle = 'edit';
            else if (Math.abs(x - left) < handleSize && Math.abs(y - top) < handleSize) handle = 'resize-nw';
            else if (Math.abs(x - right) < handleSize && Math.abs(y - bottom) < handleSize) handle = 'resize-se';
return handle;
        }

        function getArrowHandle(x, y, arrow) {
            const handleSize = 12;
            if (Math.abs(x - arrow.startX) < handleSize && Math.abs(y - arrow.startY) < handleSize) return 'start';
            if (Math.abs(x - arrow.endX) < handleSize && Math.abs(y - arrow.endY) < handleSize) return 'end';
            if (arrow.controlX && Math.abs(x - arrow.controlX) < handleSize && Math.abs(y - arrow.controlY) < handleSize) return 'control';
            return null;
        }

        function getShapeHandle(x, y, shape) {
            const handleSize = 12;
            const left = Math.min(shape.startX, shape.endX);
            const right = Math.max(shape.startX, shape.endX);
            const top = Math.min(shape.startY, shape.endY);
            const bottom = Math.max(shape.startY, shape.endY);
            
            if (Math.abs(x - left) < handleSize && Math.abs(y - top) < handleSize) return 'nw';
            if (Math.abs(x - right) < handleSize && Math.abs(y - top) < handleSize) return 'ne';
            if (Math.abs(x - left) < handleSize && Math.abs(y - bottom) < handleSize) return 'sw';
            if (Math.abs(x - right) < handleSize && Math.abs(y - bottom) < handleSize) return 'se';
            return null;
        }

        function showHandlesForObject(obj) {
            clearAllHandles();
            if (obj.text) showTextHandles(obj);
            else if (obj.startX !== undefined) {
                obj.type ? showArrowHandles(obj) : showShapeHandles(obj);
            }
        }

        function showTextHandles(textElement) {
            if (!textElement.width || !textElement.height) calculateTextDimensions(textElement);
            
            const canvasRect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const scaleX = canvasRect.width / (canvas.width / dpr);
            const scaleY = canvasRect.height / (canvas.height / dpr);
            
            let left, right, centerX;
            if (textElement.align === 'center') {
                left = (textElement.x - textElement.width / 2) * scaleX;
                right = (textElement.x + textElement.width / 2) * scaleX;
                centerX = textElement.x * scaleX;
            } else if (textElement.align === 'right') {
                left = (textElement.x - textElement.width) * scaleX;
                right = textElement.x * scaleX;
                centerX = (textElement.x - textElement.width / 2) * scaleX;
            } else {
                left = textElement.x * scaleX;
                right = (textElement.x + textElement.width) * scaleX;
                centerX = (textElement.x + textElement.width / 2) * scaleX;
            }
            
            const top = (textElement.y - textElement.height / 2) * scaleY;
            const bottom = (textElement.y + textElement.height / 2) * scaleY;
            const centerY = textElement.y * scaleY;
            
            const outline = document.createElement('div');
            outline.className = 'text-selection-outline';
            outline.style.left = `${left}px`;
            outline.style.top = `${top}px`;
            outline.style.width = `${right - left}px`;
            outline.style.height = `${bottom - top}px`;
            domElements.canvasWrapper.appendChild(outline);
            
            const handles = [
                { type: 'edit', x: right, y: top },
                { type: 'resize-nw', x: left, y: top },
                { type: 'resize-se', x: right, y: bottom }
            ];
            
            handles.forEach(handle => {
                const handleEl = document.createElement('div');
                handleEl.className = `text-handle ${handle.type}`;
                handleEl.style.left = `${handle.x - 6}px`;
                handleEl.style.top = `${handle.y - 6}px`;
                handleEl.addEventListener('mousedown', (e) => handleHandleMouseDown(e, textElement, handle.type));
                if (handle.type === 'edit') {
                    handleEl.title = 'Doble clic para editar el texto';
                    handleEl.addEventListener('dblclick', () => editTextElement(textElement));
                } else if (handle.type.startsWith('resize')) {
                    handleEl.title = 'Arrastra para redimensionar el texto';
                }
                domElements.canvasWrapper.appendChild(handleEl);
                imageState.activeHandles.push(handleEl);
            });
        }

        function showArrowHandles(arrow) {
            const canvasRect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const scaleX = canvasRect.width / (canvas.width / dpr);
            const scaleY = canvasRect.height / (canvas.height / dpr);
            
            const handles = [
                { type: 'start', x: arrow.startX * scaleX, y: arrow.startY * scaleY },
                { type: 'end', x: arrow.endX * scaleX, y: arrow.endY * scaleY }
            ];
            if (arrow.controlX && arrow.controlY) {
                handles.push({ type: 'control', x: arrow.controlX * scaleX, y: arrow.controlY * scaleY });
            }
            
            handles.forEach(handle => {
                const handleEl = document.createElement('div');
                handleEl.className = `arrow-handle ${handle.type}`;
                handleEl.style.left = `${handle.x - 4}px`;
                handleEl.style.top = `${handle.y - 4}px`;
                handleEl.addEventListener('mousedown', (e) => handleHandleMouseDown(e, arrow, handle.type));
                domElements.canvasWrapper.appendChild(handleEl);
                imageState.activeHandles.push(handleEl);
            });
        }

        function showShapeHandles(shape) {
            const canvasRect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const scaleX = canvasRect.width / (canvas.width / dpr);
            const scaleY = canvasRect.height / (canvas.height / dpr);
            
            const left = Math.min(shape.startX, shape.endX) * scaleX;
            const right = Math.max(shape.startX, shape.endX) * scaleX;
            const top = Math.min(shape.startY, shape.endY) * scaleY;
            const bottom = Math.max(shape.startY, shape.endY) * scaleY;
            
            const handles = [
                { type: 'nw', x: left, y: top }, { type: 'ne', x: right, y: top },
                { type: 'sw', x: left, y: bottom }, { type: 'se', x: right, y: bottom }
            ];
            
            handles.forEach(handle => {
                const handleEl = document.createElement('div');
                handleEl.className = `shape-handle ${handle.type}`;
                handleEl.style.left = `${handle.x - 4}px`;
                handleEl.style.top = `${handle.y - 4}px`;
                handleEl.addEventListener('mousedown', (e) => handleHandleMouseDown(e, shape, handle.type));
                domElements.canvasWrapper.appendChild(handleEl);
                imageState.activeHandles.push(handleEl);
            });
        }

        function editTextElement(textElement) {
            appState.textClickPosition = { x: textElement.x, y: textElement.y };
            
            domElements.textInput.value = textElement.text;
            domElements.textFontModal.value = textElement.font;
            domElements.textSizeModal.value = textElement.size;
            domElements.textSizeModalValue.textContent = `${textElement.size}px`;
            domElements.textColorPickerModal.value = textElement.color;
            
            document.querySelectorAll('#textModal .text-style-btn').forEach(btn => btn.classList.remove('active'));
            if (textElement.style.includes('bold')) domElements.textBoldModal.classList.add('active');
            if (textElement.style.includes('italic')) domElements.textItalicModal.classList.add('active');
            if (textElement.style.includes('underline')) domElements.textUnderlineModal.classList.add('active');
            
            document.querySelectorAll('#textModal .text-align-btn').forEach(btn => btn.classList.remove('active'));
            const alignBtns = document.querySelectorAll('#textModal .text-align-btn');
            if (textElement.align === 'left' && alignBtns[0]) alignBtns[0].classList.add('active');
            else if (textElement.align === 'center' && alignBtns[1]) alignBtns[1].classList.add('active');
            else if (textElement.align === 'right' && alignBtns[2]) alignBtns[2].classList.add('active');
            
            appState.editingTextElement = textElement;
            
            domElements.textModal.style.display = 'flex';
            domElements.textInput.focus();
            updateTextPreview();
        }

        function cropToSelection() {
            if (!imageState.selectionRect || imageState.selectionRect.width < 10 || imageState.selectionRect.height < 10) {
                clearSelection();
                return;
            }

            const rect = imageState.selectionRect;
            const dpr = window.devicePixelRatio || 1;

            // 1. Get the cropped image data from the main canvas.
            // This automatically includes all vector elements already drawn on it.
            const imageData = ctx.getImageData(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);

            // 2. Create a new Image object from the cropped data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = rect.width * dpr;
            tempCanvas.height = rect.height * dpr;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);

            const croppedImage = new Image();
            croppedImage.onload = () => {
                // 3. Update the main image state. The cropped image is the new base.
                imageState.originalImage = croppedImage;
                imageState.currentImage = croppedImage;

                // 4. Resize the main canvas to the new image dimensions
                const newWidth = rect.width;
                const newHeight = rect.height;
                canvas.width = newWidth * dpr;
                canvas.height = newHeight * dpr;
                canvas.style.width = newWidth + 'px';
                canvas.style.height = newHeight + 'px';
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // 5. Clear all vector objects as they are now part of the bitmap.
                imageState.textElements = [];
                imageState.arrows = [];
                imageState.shapes = [];
                imageState.brushStrokes = [];
                imageState.selectedObject = null;

                // 6. Clean up and redraw
                clearSelection();
                redrawCanvas(); // This will now draw the new originalImage
                updateStatusBar();
                updateHistogram();
                saveToHistory();
                showNotification('‚úÇÔ∏è Imagen recortada', 'success');
            };
            croppedImage.src = tempCanvas.toDataURL();
        }

         function handleCanvasWheel(e) {
             // Solo hacer zoom con CTRL+rueda cuando el cursor est√© directamente sobre la imagen
             if (e.ctrlKey) {
                 e.preventDefault(); // Solo prevenir cuando hacemos zoom
                 const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05; // Zoom m√°s suave
                 const canvasRect = canvas.getBoundingClientRect();
                 const mouseX = e.clientX - canvasRect.left;
                 const mouseY = e.clientY - canvasRect.top;
                 
                 // Verificar que el cursor est√° sobre la imagen
                 if (mouseX >= 0 && mouseX <= canvasRect.width && mouseY >= 0 && mouseY <= canvasRect.height) {
                     zoomAtPoint(mouseX, mouseY, zoomFactor);
                 }
             }
             // Sin CTRL: dejar que el evento burbuje para permitir scroll normal
         }

         function handleContainerWheel(e) {
             // Solo prevenir el scroll del contenedor si hay CTRL (para permitir zoom en canvas)
             if (e.ctrlKey) {
                 e.preventDefault();
             }
             // Sin CTRL: permitir scroll normal - el navegador lo maneja autom√°ticamente
         }

         function zoomIn(x, y) { 
             // x e y son coordenadas del canvas (posici√≥n relativa al canvas)
             zoomAtPoint(x, y, 1.25); 
         }
         function zoomOut(x, y) { 
             // x e y son coordenadas del canvas (posici√≥n relativa al canvas)
             zoomAtPoint(x, y, 0.8); 
         }

         function zoomAtPoint(mouseX, mouseY, factor) {
             const newZoom = Math.max(0.1, Math.min(10, appState.zoomLevel * factor));
             if (newZoom === appState.zoomLevel) return;
             
             const wrapper = domElements.canvasWrapper;
             const container = domElements.canvasContainer;
             if (!wrapper || !canvas || !container) return;
             
             // Calcular el punto de origen del zoom como porcentaje del canvas
             const canvasWidth = canvas.offsetWidth;
             const canvasHeight = canvas.offsetHeight;
             const originX = (mouseX / canvasWidth) * 100;
             const originY = (mouseY / canvasHeight) * 100;
             
             // Aplicar el zoom manteniendo la imagen centrada
             wrapper.style.transformOrigin = `${originX}% ${originY}%`;
             wrapper.style.transform = `translate(-50%, -50%) scale(${newZoom})`;
             
             // Ajustar el padding del contenedor para crear espacio de scroll sin franjas blancas
             if (newZoom > 1) {
                 const canvasWidth = canvas.offsetWidth;
                 const canvasHeight = canvas.offsetHeight;
                 const extraSpaceX = Math.max(0, (canvasWidth * newZoom - canvasWidth) / 2);
                 const extraSpaceY = Math.max(0, (canvasHeight * newZoom - canvasHeight) / 2);
                 container.style.padding = `${extraSpaceY}px ${extraSpaceX}px`;
             } else {
                 container.style.padding = '0px';
             }
             
             appState.zoomLevel = newZoom;
             updateStatusBar();
         }

         function resetZoom() {
             appState.zoomLevel = 1;
             if (domElements.canvasWrapper) {
                 const wrapper = domElements.canvasWrapper;
                 const container = domElements.canvasContainer;
                 wrapper.style.transform = 'translate(-50%, -50%) scale(1)';
                 wrapper.style.transformOrigin = 'center center';
                 if (container) {
                     container.style.padding = '0px';
                 }
             }
             updateStatusBar();
         }

         // Cambiar cursor cuando se puede hacer zoom
         function updateZoomCursor(e) {
             if (canvas && e.ctrlKey) {
                 canvas.style.cursor = 'zoom-in';
             } else {
                 canvas.style.cursor = getCursorForTool(appState.currentTool);
             }
         }

         function getCursorForTool(tool) {
             const cursorMap = {
                 select: 'default',
                 crop: 'crosshair',
                 brush: 'crosshair',
                 eraser: 'crosshair',
                 text: 'text',
                 zoom: 'zoom-in',
                 arrow: 'crosshair',
                 gradient: 'crosshair',
                 clone: 'crosshair',
                 heal: 'crosshair',
                 shapes: 'crosshair',
                 eyedropper: 'crosshair'
             };
             return cursorMap[tool] || 'crosshair';
         }
         
         function updateCropCursor(e) {
             if (appState.currentTool === 'crop' && imageState.cropHandles.active) {
                 const pos = getCanvasMousePos(e);
                 const handle = getCropHandleAtPosition(pos.x, pos.y);
                 
                 if (handle) {
                     // Cursores espec√≠ficos para cada tipo de handle
                     const cursorMap = {
                         'top-left': 'nw-resize',
                         'top-center': 'n-resize',
                         'top-right': 'ne-resize',
                         'middle-left': 'w-resize',
                         'middle-right': 'e-resize',
                         'bottom-left': 'sw-resize',
                         'bottom-center': 's-resize',
                         'bottom-right': 'se-resize'
                     };
                     canvas.style.cursor = cursorMap[handle.type] || 'move';
                 } else {
                     canvas.style.cursor = 'crosshair';
                 }
             }
         }
        function updateTextPreview() {
            if (!domElements.textPreview) return;
            
            const text = domElements.textInput.value || 'Vista previa del texto aparecer√° aqu√≠...';
            const font = domElements.textFontModal?.value || domElements.textFont?.value || 'Arial';
            const size = domElements.textSizeModal?.value || domElements.textSize?.value || '24';
            const color = domElements.textColorPickerModal?.value || document.getElementById('textColorPicker')?.value || '#FF0000';
            const align = toolSettings.text.align || 'left';
            
            const isBold = domElements.textBoldModal?.classList.contains('active') || document.getElementById('textBold')?.classList.contains('active');
            const isItalic = domElements.textItalicModal?.classList.contains('active') || document.getElementById('textItalic')?.classList.contains('active');
            const isUnderline = domElements.textUnderlineModal?.classList.contains('active') || document.getElementById('textUnderline')?.classList.contains('active');
            
            domElements.textPreview.style.fontFamily = `"${font}", sans-serif`;
            domElements.textPreview.style.fontSize = `${size}px`;
            domElements.textPreview.style.color = color;
            domElements.textPreview.style.fontWeight = isBold ? 'bold' : 'normal';
            domElements.textPreview.style.fontStyle = isItalic ? 'italic' : 'normal';
            domElements.textPreview.style.textDecoration = isUnderline ? 'underline' : 'none';
            domElements.textPreview.style.textAlign = align;
            domElements.textPreview.style.lineHeight = '1.4';
            domElements.textPreview.innerHTML = text.replace(/\n/g, '<br>');
            
            toolSettings.text.font = font;
            toolSettings.text.size = parseInt(size);
            toolSettings.currentColor = color;
            
            let styleString = [isBold ? 'bold' : '', isItalic ? 'italic' : '', isUnderline ? 'underline' : ''].filter(Boolean).join(' ');
            toolSettings.text.style = styleString || 'normal';
            toolSettings.text.align = align;
        }
        function closeTextModal(){
            if (domElements.textModal) domElements.textModal.style.display = 'none';
        }

        function initializeFloatingShapesPanel(){}
        function updateFloatingShapeType(v){ toolSettings.shape.type = v; }
        function updateFloatingShapeStyle(v){ toolSettings.shape.style = v; }
        function updateFloatingShapeStrokeWidth(v){ toolSettings.shape.strokeWidth = parseInt(v); }
        function updateFloatingShapeFillColor(v){ toolSettings.shape.fillColor = v; }
        function updateFloatingShapeStrokeColor(v){ toolSettings.shape.strokeColor = v; }
        function updateFloatingShapeOpacity(v){ toolSettings.shape.opacity = parseInt(v); }
        function updateFloatingStarSpikes(v){ toolSettings.shape.starSpikes = parseInt(v); }
        function updateFloatingStarDepth(v){ toolSettings.shape.starDepth = parseFloat(v); }
        function updateFloatingSpiralTurns(v){ toolSettings.shape.spiralTurns = parseInt(v); }
        function updateFloatingArcStartAngle(v){ toolSettings.shape.arcStartAngle = parseInt(v); }
        function updateFloatingArcEndAngle(v){ toolSettings.shape.arcEndAngle = parseInt(v); }
        function updateFloatingGearTeeth(v){ toolSettings.shape.gearTeeth = parseInt(v); }
        function updateTextFont(v){
            toolSettings.text.font = v;
            domElements.textSizeModalValue.textContent = `${toolSettings.text.size}px`;
        }
        
        function updateTextSize(v){
            toolSettings.text.size = parseInt(v);
            domElements.textSizeModalValue.textContent = `${v}px`;
            if (domElements.textSizeValue) {
                domElements.textSizeValue.textContent = `${v}px`;
            }
        }
        
        function toggleTextStyle(style){
            const modalBtn = document.getElementById(`text${style.charAt(0).toUpperCase() + style.slice(1)}Modal`);
            const panelBtn = document.getElementById(`text${style.charAt(0).toUpperCase() + style.slice(1)}`);
            
            const isActive = modalBtn ? modalBtn.classList.toggle('active') : panelBtn.classList.toggle('active');
            if (modalBtn) modalBtn.classList.toggle('active', isActive);
            if (panelBtn) panelBtn.classList.toggle('active', isActive);
            
            let currentStyles = new Set((toolSettings.text.style || 'normal').split(' ').filter(s => s !== 'normal'));
            isActive ? currentStyles.add(style) : currentStyles.delete(style);
            toolSettings.text.style = [...currentStyles].join(' ') || 'normal';
        }
        
        function updateTextAlign(align){
            toolSettings.text.align = align;
            document.querySelectorAll('.text-align-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll(`#textModal .text-align-btn, #textProperties .text-align-btn`).forEach(btn => {
                if (btn.textContent.toLowerCase().includes(align)) btn.classList.add('active');
            });
        }
        
        function updateTextColor(color){
            toolSettings.currentColor = color;
            if (domElements.textColorPickerModal) domElements.textColorPickerModal.value = color;
            if (document.getElementById('textColorPicker')) document.getElementById('textColorPicker').value = color;
        }
        
        function addTextToCanvas(){
            if (appState.currentTool !== 'text') selectTool('text');
            
            const dpr = window.devicePixelRatio || 1;
            appState.textClickPosition = { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 };
            
            domElements.textModal.style.display = 'flex';
            domElements.textInput.value = '';
            domElements.textInput.focus();
            updateTextPreview();
        }

        function updateFilter(type, value) {
            if (!toolSettings.filters) return;
            toolSettings.filters[type] = parseInt(value);
            const valueDisplay = document.getElementById(type + 'Value');
            if (valueDisplay) valueDisplay.textContent = value;
            
            requestAnimationFrame(redrawCanvas);
        }
        
        function applyFilter(preset) {
            if (!preset || preset === 'original') {
                resetFilters();
                redrawCanvas();
                return;
            }
            const presets = {
                'vintage': { sepia: 40, contrast: 10, saturation: -20 }, 'bw': { saturation: -100 },
                'sepia': { sepia: 80 }, 'polaroid': { contrast: 15, brightness: 10, saturation: 20 },
                'warm': { temperature: 20, brightness: 5 }, 'cool': { temperature: -20, brightness: 5 },
                'dramatic': { contrast: 30, brightness: -10 }, 'soft': { brightness: 10, contrast: -10 }
            };
            
            const filterSet = presets[preset];
            if (filterSet) {
                resetFilters(); 
                Object.assign(toolSettings.filters, filterSet);
                updateAllFilterSlidersUI();
                redrawCanvas();
            }
        }
        
        function getFilterCssString() {
            if (!toolSettings.filters) return 'none';
            
            const { brightness, contrast, saturation, hue, blur } = toolSettings.filters;
            
            const filters = [
                brightness !== 0 ? `brightness(${100 + brightness}%)` : '',
                contrast !== 0 ? `contrast(${100 + contrast}%)` : '',
                saturation !== 0 ? `saturate(${100 + saturation}%)` : '',
                hue !== 0 ? `hue-rotate(${hue}deg)` : '',
                blur > 0 ? `blur(${blur / 10}px)` : ''
            ].filter(Boolean).join(' ');
            
            return filters || 'none';
        }
        function rotateImage(angle){}
        function flipImage(dir){}
        function resizeCanvas(){}
        function addLayer(){}
        
        function newImage() {
            // Asegurar que canvas y ctx esten inicializados
            if (!canvas || !ctx) {
                initializeCanvas();
            }
            if (!canvas || !ctx) {
                console.error('No se pudo inicializar el canvas');
                return;
            }
            
            let width, height;
            const sizeConfig = {
                fullscreen: () => {
                    const rect = domElements.canvasContainer.getBoundingClientRect();
                    return [Math.min(rect.width - 40, window.innerWidth - 400), Math.min(rect.height - 40, window.innerHeight - 200)];
                },
                hd: () => [1920, 1080],
                '4k': () => [3840, 2160],
                'square-lg': () => [1080, 1080],
                'square-md': () => [800, 800],
                a4: () => [794, 1123],
                custom: () => [appSettings.canvas.width, appSettings.canvas.height]
            };
            [width, height] = sizeConfig[appSettings.canvas.size] ? sizeConfig[appSettings.canvas.size]() : sizeConfig.hd();
            
            const maxWidth = window.innerWidth - 400;
            const maxHeight = window.innerHeight - 200;
            if (width > maxWidth || height > maxHeight) {
                const scale = Math.min(maxWidth / width, maxHeight / height);
                width = Math.floor(width * scale);
                height = Math.floor(height * scale);
            }
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            ctx.fillStyle = appSettings.canvas.backgroundColor;
            ctx.fillRect(0, 0, width, height);
            
            domElements.canvasWidth.value = width;
            domElements.canvasHeight.value = height;
            
            domElements.dropZone.style.display = 'none';
            domElements.canvasWrapper.style.display = 'block';
            
            // Limpiar informaci√≥n del archivo actual al crear nueva imagen
            imageState.currentFile = null;
            
            // Asegurar que todos los elementos DOM est√©n disponibles
            cacheDOMElements();
            
            resetEditorState();
            resetZoom();
            selectTool(appSettings.tools.defaultTool);
            updateStatusBar();
            updateHistogram();
        }

        function saveImage() {
            if (!canvas) return;
            
            // 1. Guardar estados actuales
            const originalCropActive = imageState.cropHandles.active;
            const originalCloneSelection = imageState.cloneSelection;
            
            // 2. Desactivar elementos de interfaz
            imageState.cropHandles.active = false;
            imageState.cloneSelection = null;
            
            // 3. Crear canvas temporal para exportaci√≥n limpia
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            
            // 4. Redibujar en el contexto temporal (sin los puntos de control)
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;

            exportCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            exportCtx.imageSmoothingEnabled = true;
            exportCtx.imageSmoothingQuality = 'high';
            
            // Fondo blanco
            exportCtx.fillStyle = '#FFFFFF';
            exportCtx.fillRect(0, 0, width, height);

            // Imagen base con filtros CSS
            exportCtx.save();
            exportCtx.filter = getFilterCssString();
            if (imageState.originalImage) {
                exportCtx.drawImage(imageState.originalImage, 0, 0, width, height);
            }
            exportCtx.restore();

            // Guardar contexto original para que las funciones de dibujo usen el temporal
            const mainCtx = ctx;
            ctx = exportCtx;

            // Filtros no-CSS
            if (toolSettings.filters.vignette > 0) applyVignette(width, height);
            if (toolSettings.filters.grain > 0) applyGrain(canvas.width, canvas.height);
            if (toolSettings.filters.sharpen > 0) applySharpen(canvas.width, canvas.height);

            // Elementos vectoriales
            imageState.shapes.forEach(shape => drawShape(shape));
            imageState.arrows.forEach(arrow => drawArrow(arrow));
            imageState.textElements.forEach(text => drawTextElement(text));
            imageState.brushStrokes.forEach(stroke => drawBrushStroke(stroke));
            
            // Restaurar contexto principal
            ctx = mainCtx;

            // 5. Descargar desde el canvas limpio
            const link = document.createElement('a');
            link.download = `imaxe_${new Date().toISOString().slice(0, 10)}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
            
            // 6. Restaurar estado de interfaz
            imageState.cropHandles.active = originalCropActive;
            imageState.cloneSelection = originalCloneSelection;
            redrawCanvas();
        }

        function exportImage() {
            if (!canvas) return;
            
            domElements.exportFileName.value = `imaxe_${new Date().toISOString().slice(0, 10)}`;
            
            const hasModernAPI = !!window.showSaveFilePicker;
            domElements.modernApiInfo.style.display = hasModernAPI ? 'block' : 'none';
            domElements.fallbackInfo.style.display = hasModernAPI ? 'none' : 'block';
            
            domElements.exportModal.style.display = 'flex';
            
            setTimeout(() => {
                domElements.exportFileName.focus();
                domElements.exportFileName.select();
            }, 100);
        }

        function performExport() {
            let fileName = (domElements.exportFileName.value.trim() || `imaxe_${new Date().toISOString().slice(0, 10)}`).replace(/[<>:"/\|?*]/g, '_');
            const format = domElements.exportFormat.value;
            const quality = domElements.exportQuality.value;
            const size = domElements.exportSize.value;
            
            // 1. Guardar estados actuales
            const originalCropActive = imageState.cropHandles.active;
            const originalCloneSelection = imageState.cloneSelection;
            
            // 2. Desactivar elementos de interfaz
            imageState.cropHandles.active = false;
            imageState.cloneSelection = null;
            
            // 3. Crear canvas temporal para exportaci√≥n limpia
            const cleanCanvas = document.createElement('canvas');
            const cleanCtx = cleanCanvas.getContext('2d');
            cleanCanvas.width = canvas.width;
            cleanCanvas.height = canvas.height;
            
            // 4. Redibujar versi√≥n limpia
            const dpr = window.devicePixelRatio || 1;
            const width = canvas.width / dpr;
            const height = canvas.height / dpr;

            cleanCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            cleanCtx.imageSmoothingEnabled = true;
            cleanCtx.imageSmoothingQuality = 'high';
            
            // Fondo blanco
            cleanCtx.fillStyle = '#FFFFFF';
            cleanCtx.fillRect(0, 0, width, height);

            // Imagen base con filtros CSS
            cleanCtx.save();
            cleanCtx.filter = getFilterCssString();
            if (imageState.originalImage) {
                cleanCtx.drawImage(imageState.originalImage, 0, 0, width, height);
            }
            cleanCtx.restore();

            // Guardar contexto original para que las funciones de dibujo usen el temporal
            const mainCtx = ctx;
            ctx = cleanCtx;

            // Filtros no-CSS
            if (toolSettings.filters.vignette > 0) applyVignette(width, height);
            if (toolSettings.filters.grain > 0) applyGrain(cleanCanvas.width, cleanCanvas.height);
            if (toolSettings.filters.sharpen > 0) applySharpen(cleanCanvas.width, cleanCanvas.height);

            // Elementos vectoriales
            imageState.shapes.forEach(shape => drawShape(shape));
            imageState.arrows.forEach(arrow => drawArrow(arrow));
            imageState.textElements.forEach(text => drawTextElement(text));
            imageState.brushStrokes.forEach(stroke => drawBrushStroke(stroke));
            
            // Restaurar contexto principal
            ctx = mainCtx;

            // 5. Preparar el canvas de exportaci√≥n final (con redimensionado si es necesario)
            let exportCanvas = cleanCanvas;
            
            if (size !== 'original') {
                exportCanvas = document.createElement('canvas');
                const exportCtx = exportCanvas.getContext('2d');
                const sizeMap = { hd: [1920, 1080], social: [1080, 1080], web: [800, 600] };
                [exportCanvas.width, exportCanvas.height] = sizeMap[size];
                exportCtx.drawImage(cleanCanvas, 0, 0, exportCanvas.width, exportCanvas.height);
            }
            
            exportCanvas.toBlob(async (blob) => {
                try {
                    if (window.showSaveFilePicker) {
                        const result = await saveWithModernAPI(fileName, format, blob);
                        if (result.success || result.cancelled) {
                            // Restaurar estado de interfaz
                            imageState.cropHandles.active = originalCropActive;
                            imageState.cloneSelection = originalCloneSelection;
                            redrawCanvas();
                            closeModal('exportModal');
                            return;
                        }
                    }
                    const link = document.createElement('a');
                    link.download = `${fileName}.${format}`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                    
                    // Restaurar estado de interfaz
                    imageState.cropHandles.active = originalCropActive;
                    imageState.cloneSelection = originalCloneSelection;
                    redrawCanvas();
                    closeModal('exportModal');
                } catch (error) {
                    // Restaurar estado incluso en caso de error
                    imageState.cropHandles.active = originalCropActive;
                    imageState.cloneSelection = originalCloneSelection;
                    redrawCanvas();
                    showNotification(`‚ùå Error al guardar: ${error.message}`, 'error');
                }
            }, `image/${format}`, format === 'png' ? undefined : parseFloat(quality));
        }

        async function saveWithModernAPI(fileName, format, blob) {
            try {
                const options = {
                    suggestedName: `${fileName}.${format}`,
                    types: [{
                        description: 'Im√°genes',
                        accept: { 'image/png': ['.png'], 'image/jpeg': ['.jpg', '.jpeg'], 'image/webp': ['.webp'] }
                    }]
                };
                const fileHandle = await window.showSaveFilePicker(options);
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
                return { success: true, path: fileHandle.name };
            } catch (error) {
                if (error.name === 'AbortError') return { success: false, cancelled: true };
                throw error;
            }
        }

        function toggleTheme() {
            const newTheme = document.body.dataset.theme === 'dark' ? 'light' : 'dark';
            document.body.dataset.theme = newTheme;
            appSettings.ui.theme = newTheme;
            if (appSettings.performance.autoSave) {
                localStorage.setItem('editorSettings', JSON.stringify(appSettings));
            }
        }

        function toggleFullscreen() {
            document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen().catch(err => {});
        }

        function showHelpModal() { domElements.helpModal.style.display = 'flex'; }
        function closeHelpModal() { closeModal('helpModal'); }
        function closeModal(id) {
            const modal = document.getElementById(id);
            if (modal) modal.style.display = 'none';
        }

        // =================================================================================
        // SECTION: EYEDROPPER TOOL
        // =================================================================================

                 async function activateEyedropper() {
             // Si ya est√° activo, desactivar
             if (appState.eyedropperActive) {
                 deactivateEyedropper();
                 return;
             }
             
             // Activar modo cuentagotas
             appState.eyedropperActive = true;
             appState.currentTool = 'eyedropper';
             
             // Usar el sistema de herramientas existente
             updateToolButtonHighlight('eyedropper');
             updateCursor();
             
             // Crear indicador de color y asegurar que aparezca
             createColorIndicator();
             
             // Mostrar indicador inmediatamente con color por defecto
             const indicator = document.getElementById('colorIndicator');
             if (indicator) {
                 indicator.style.display = 'block';
                 updateColorIndicatorContent('#000000');
             }
             
             // Activar listener de teclado
             document.addEventListener('keydown', handleEyedropperKeydown);
             
             // Intentar usar EyeDropper API nativo si est√° disponible (Chrome)
             if ('EyeDropper' in window) {
                 try {
                     const eyeDropper = new EyeDropper();
                     const result = await eyeDropper.open();
                     if (result.sRGBHex) {
                         setSelectedColorUniversal(result.sRGBHex);
                         deactivateEyedropper();
                         return;
                     }
                 } catch (error) {
     
                 }
             }
             
             // Mostrar notificaci√≥n de modo manual
             showNotification('üíß Cuentagotas activado - Mueve el cursor SOBRE LA IMAGEN para ver colores en tiempo real', 'info');

         }
        
                 function deactivateEyedropper() {
             appState.eyedropperActive = false;
             
             // Cambiar a la herramienta de selecci√≥n usando el sistema integrado
             selectTool('select');
             
             // Remover indicador de color
             removeColorIndicator();
             
             // Limpiar el estilo de la informaci√≥n del pixel
             if (domElements.pixelInfo) {
                 domElements.pixelInfo.style.color = '';
                 domElements.pixelInfo.style.fontWeight = '';
             }
             
             // Remover event listeners
             document.removeEventListener('keydown', handleEyedropperKeydown);
             
             // Tambi√©n remover los listeners viejos por si acaso
             document.removeEventListener('mousemove', handleGlobalEyedropperMouseMove);
             document.removeEventListener('click', handleGlobalEyedropperClick);
             document.removeEventListener('mousemove', handleEyedropperMouseMove);
             document.removeEventListener('click', handleEyedropperClick);
             canvas.removeEventListener('mousemove', handleCanvasEyedropperMouseMove);
             canvas.removeEventListener('click', handleCanvasEyedropperClick);
             
             // Limpiar overlay si existe
             const overlay = document.getElementById('eyedropperOverlay');
             if (overlay) {
                 document.body.removeChild(overlay);
             }
             
             // Mostrar notificaci√≥n de desactivaci√≥n
             showNotification('üíß Cuentagotas desactivado', 'info');
         }

         function handleEyedropperMouseMove(e, pos) {
             if (!appState.eyedropperActive) return;
             
             // Crear indicador si no existe
             let indicator = document.getElementById('colorIndicator');
             if (!indicator) {
                 createColorIndicator();
                 indicator = document.getElementById('colorIndicator');
             }
             
             if (!indicator) return;
             
             // Asegurar que el indicador est√© visible
             indicator.style.display = 'block';
             
             // Posicionar el indicador cerca del cursor con mejor posicionamiento
             const x = e.clientX;
             const y = e.clientY;
             const offsetX = x + 20 + 140 > window.innerWidth ? x - 160 : x + 20;
             const offsetY = y - 80 < 0 ? y + 20 : y - 80;
             
             indicator.style.left = offsetX + 'px';
             indicator.style.top = offsetY + 'px';
             
             // Obtener el color en la posici√≥n actual
             const color = getColorAtPosition(pos.x, pos.y);
             
             if (color) {
                 // Actualizar el indicador flotante
                 updateColorIndicatorContent(color);
                 
                 // La informaci√≥n RGB ya se actualiza autom√°ticamente por updatePixelInfo
                 return;
             }
             
             // Si no se puede obtener el color, mostrar por defecto
             updateColorIndicatorContent('#000000');
         }

         function handleEyedropperClick(e, pos) {
             if (!appState.eyedropperActive) return;
             
             e.preventDefault();
             e.stopPropagation();
             
             const color = getColorAtPosition(pos.x, pos.y);
             
             if (color) {
                 setSelectedColorUniversal(color);
                 deactivateEyedropper();
                 
                 // Mantener el color seleccionado visible por un momento
                 appState.lockStatusBarColor = true;
                 setTimeout(() => {
                     appState.lockStatusBarColor = false;
                 }, 2000);
             }
         }



         function updateColorIndicatorContent(color) {
             const indicator = document.getElementById('colorIndicator');
             if (!indicator) return;
             
             const colorBox = indicator.querySelector('div');
             const colorText = indicator.querySelector('div:nth-child(2)');
             
             if (colorBox) colorBox.style.background = color;
             if (colorText) colorText.textContent = color.toUpperCase();
             
             // Obtener valores RGB para mostrar informaci√≥n adicional
             const r = parseInt(color.slice(1, 3), 16);
             const g = parseInt(color.slice(3, 5), 16);
             const b = parseInt(color.slice(5, 7), 16);
             
             const rgbText = indicator.querySelector('div:last-child');
             if (rgbText) {
                 rgbText.textContent = `RGB: ${r}, ${g}, ${b}`;
                 rgbText.style.color = '#666';
                 rgbText.style.fontSize = '9px';
             }
         }



         function createColorIndicator() {
             // Evitar duplicados
             if (document.getElementById('colorIndicator')) return;
             
             // Crear indicador de color flotante
             const indicator = document.createElement('div');
             indicator.id = 'colorIndicator';
             indicator.style.cssText = `
                 position: fixed;
                 width: 140px;
                 height: 70px;
                 background: white;
                 border: 2px solid #333;
                 border-radius: 8px;
                 box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                 z-index: 10000;
                 pointer-events: none;
                 display: none;
                 font-family: monospace;
                 font-size: 11px;
                 color: #333;
                 text-align: center;
                 padding: 5px;
                 user-select: none;
                 backdrop-filter: blur(10px);
             `;
             
             indicator.innerHTML = `
                 <div style="width: 100%; height: 35px; border-radius: 4px; margin-bottom: 3px; background: #ffffff; border: 1px solid #ddd;"></div>
                 <div style="font-weight: bold; font-size: 10px;">#FFFFFF</div>
                 <div style="font-size: 9px; color: #666;">Click para seleccionar</div>
             `;
             
             document.body.appendChild(indicator);
         }

         function removeColorIndicator() {
             const indicator = document.getElementById('colorIndicator');
             if (indicator) {
                 document.body.removeChild(indicator);
             }
         }

         function updateColorIndicator(x, y, color) {
             const indicator = document.getElementById('colorIndicator');
             if (!indicator) return;
             
             // Actualizar contenido del color
             updateColorIndicatorContent(color);
             
             // Posicionar el indicador cerca del cursor
             indicator.style.left = (x + 20) + 'px';
             indicator.style.top = (y - 70) + 'px';
             indicator.style.display = 'block';
         }



         function handleEyedropperKeydown(e) {
             if (e.key === 'Escape' || e.key.toLowerCase() === 'd') {
                 e.preventDefault();
                 deactivateEyedropper();
             }
         }

         function getColorAtPosition(x, y) {
             if (!canvas || !ctx) return null;
             
             try {
                 const dpr = window.devicePixelRatio || 1;
                 const pixelX = Math.floor(x * dpr);
                 const pixelY = Math.floor(y * dpr);
                 
                 if (pixelX < 0 || pixelY < 0 || pixelX >= canvas.width || pixelY >= canvas.height) {
                     return null;
                 }
                 
                 const imageData = ctx.getImageData(pixelX, pixelY, 1, 1);
                 const [r, g, b] = imageData.data;
                 
                                 return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            } catch (error) {
                return null;
            }
         }

        function setSelectedColorUniversal(hexColor) {
            // Actualizar color global
            toolSettings.currentColor = hexColor;
            
            // Actualizar todas las herramientas
            toolSettings.brush.color = hexColor;
            toolSettings.arrow.color = hexColor;
            toolSettings.text.color = hexColor;
            toolSettings.shape.fillColor = hexColor;
            toolSettings.shape.strokeColor = hexColor;
            
            // Actualizar selectores de color en la interfaz
            const colorInputs = document.querySelectorAll('input[type="color"]');
            colorInputs.forEach(input => {
                if (input.id === 'textColorPicker' || 
                    input.id === 'textColorPickerModal' ||
                    input.id === 'arrowColor' ||
                    input.id === 'shapeFillColor' ||
                    input.id === 'shapeStrokeColor') {
                    input.value = hexColor;
                }
            });
            
            // A√±adir a paleta de colores como color personalizado
            addCustomColorToPalette(hexColor);
            
            // Actualizar barra de estado
            updateStatusBarWithColor(hexColor);
            
            // Actualizar UI de herramientas
            updateAllToolPropertiesUI();
            
            // Mostrar notificaci√≥n del color seleccionado
            showColorNotification(hexColor);
        }

        function addCustomColorToPalette(hexColor) {
            // Buscar si ya existe un √°rea de colores personalizados
            let customSection = document.querySelector('.custom-colors-section');
            
            if (!customSection) {
                // Crear secci√≥n de colores personalizados
                const palettePanel = document.getElementById('colorPalettePanel');
                if (palettePanel) {
                    customSection = document.createElement('div');
                    customSection.className = 'custom-colors-section';
                    customSection.innerHTML = `
                        <div style="padding: 10px; border-top: 1px solid var(--border);">
                            <small style="color: var(--text-secondary); font-weight: bold;">Colores Personalizados:</small>
                            <div class="custom-colors-grid" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 5px;">
                            </div>
                        </div>
                    `;
                    palettePanel.appendChild(customSection);
                }
            }
            
            const customGrid = customSection?.querySelector('.custom-colors-grid');
            if (!customGrid) return;
            
            // Verificar si el color ya existe
            const existingColors = customGrid.querySelectorAll('.custom-color-swatch');
            for (const swatch of existingColors) {
                if (swatch.style.backgroundColor === hexColor) {
                    return; // Color ya existe
                }
            }
            
            // Crear nuevo swatch
            const swatch = document.createElement('div');
            swatch.className = 'custom-color-swatch color-swatch';
            swatch.style.cssText = `
                width: 24px;
                height: 24px;
                background-color: ${hexColor};
                border-radius: 4px;
                cursor: pointer;
                border: 2px solid transparent;
                transition: border-color 0.2s;
            `;
            
            swatch.title = hexColor.toUpperCase();
            swatch.addEventListener('click', () => {
                setSelectedColorUniversal(hexColor);
            });
            
            // A√±adir al inicio de la grid
            customGrid.insertBefore(swatch, customGrid.firstChild);
            
            // Limitar a m√°ximo 12 colores personalizados
            const allCustomColors = customGrid.querySelectorAll('.custom-color-swatch');
            if (allCustomColors.length > 12) {
                customGrid.removeChild(allCustomColors[allCustomColors.length - 1]);
            }
        }

        function updateStatusBarWithColor(hexColor) {
            if (domElements.pixelInfo) {
                // Obtener valores RGB del color hex
                const r = parseInt(hexColor.slice(1, 3), 16);
                const g = parseInt(hexColor.slice(3, 5), 16);
                const b = parseInt(hexColor.slice(5, 7), 16);
                
                domElements.pixelInfo.innerHTML = `üé® RGB: ${r}, ${g}, ${b} | ${hexColor.toUpperCase()}`;
                
                // A√±adir clase visual para resaltar el color seleccionado
                domElements.pixelInfo.style.fontWeight = 'bold';
                domElements.pixelInfo.style.color = '#4CAF50';
                
                // Volver al estilo normal despu√©s de un momento
                setTimeout(() => {
                    domElements.pixelInfo.style.fontWeight = '';
                    domElements.pixelInfo.style.color = '';
                }, 1500);
            }
        }

        // Mantener funci√≥n original para compatibilidad
        function setSelectedColor(hexColor) {
            setSelectedColorUniversal(hexColor);
        }

        // ========================================
        // FUNCIONALIDAD DE REEMPLAZO DE COLOR
        // ========================================
        
        let colorReplaceState = {
            active: false,
            sourceColor: null,
            targetColor: '#00ff00',
            tolerance: 10,
            previewMode: false,
            previewCanvas: null,
            previewCtx: null,
            originalImageData: null,
            pickerMode: null // 'source' or 'target'
        };



        function initializeColorReplace() {
            // Guardar imagen original para vista previa
            if (canvas && ctx) {
                colorReplaceState.originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
            
            // Crear canvas de vista previa
            if (!colorReplaceState.previewCanvas) {
                colorReplaceState.previewCanvas = document.createElement('canvas');
                colorReplaceState.previewCtx = colorReplaceState.previewCanvas.getContext('2d');
            }
            
            // Crear y mostrar el men√∫ flotante
            createColorReplaceFloatingMenu();
            
            updateColorReplaceInfo('Herramienta de reemplazo de color activada');
        }

        function createColorReplaceFloatingMenu() {
            // Remover men√∫ anterior si existe
            const existingMenu = document.getElementById('colorReplaceFloatingMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // Crear men√∫ flotante
            const floatingMenu = document.createElement('div');
            floatingMenu.id = 'colorReplaceFloatingMenu';
            floatingMenu.style.cssText = `
                position: fixed;
                left: 80px;
                top: 120px;
                background: var(--bg-secondary);
                border: 2px solid var(--border);
                border-radius: 12px;
                padding: 16px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                z-index: 1000;
                width: 220px;
                backdrop-filter: blur(10px);
                transition: all 0.3s ease;
            `;
            
            floatingMenu.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                    <h3 style="margin: 0; font-size: 14px; color: var(--text-primary);">üé® Reemplazo de Color</h3>
                    <div style="display: flex; gap: 4px;">
                        <button onclick="showColorReplaceHelp()" style="background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 14px; padding: 4px;" title="Ayuda">‚ùì</button>
                        <button onclick="hideColorReplaceMenu()" style="background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 16px; padding: 4px;">‚úï</button>
                    </div>
                </div>
                
                <!-- Color Origen -->
                <div style="margin-bottom: 14px;">
                    <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                        üéØ Color Origen
                    </label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 40px; height: 40px; border: 2px solid var(--border); border-radius: 8px; background: ${colorReplaceState.sourceColor || '#ff0000'}; cursor: pointer; position: relative;" 
                             id="sourceColorDisplay" onclick="activateMouseColorPicker()">
                            <div style="position: absolute; bottom: -2px; right: -2px; background: white; border-radius: 50%; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; font-size: 10px;">üíß</div>
                        </div>
                        <div style="flex: 1;">
                            <div style="font-size: 11px; color: var(--text-primary); font-weight: bold;" id="sourceColorText">
                                ${colorReplaceState.sourceColor || 'Seleccionar'}
                            </div>
                            <div style="font-size: 9px; color: var(--text-secondary);">
                                Clic en imagen
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Color Destino -->
                <div style="margin-bottom: 14px;">
                    <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                        üé® Color Destino
                    </label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 40px; height: 40px; border: 2px solid var(--border); border-radius: 8px; background: ${colorReplaceState.targetColor}; cursor: pointer;" 
                             id="targetColorDisplay" onclick="showColorPaletteForTarget()">
                        </div>
                        <div style="flex: 1;">
                            <div style="font-size: 11px; color: var(--text-primary); font-weight: bold;" id="targetColorText">
                                ${colorReplaceState.targetColor.toUpperCase()}
                            </div>
                            <div style="font-size: 9px; color: var(--text-secondary);">
                                Clic para paleta
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Tolerancia -->
                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px;">
                        üéöÔ∏è Tolerancia: <span id="toleranceValueDisplay">${colorReplaceState.tolerance}</span>%
                    </label>
                    <input type="range" id="toleranceSlider" min="0" max="100" value="${colorReplaceState.tolerance}" 
                           style="width: 100%; height: 6px; background: var(--bg-tertiary); border-radius: 3px; outline: none; cursor: pointer;"
                           oninput="updateToleranceFromSlider(this.value)">
                </div>
                
                <!-- Botones de Acci√≥n -->
                <div style="display: flex; gap: 8px; margin-top: 12px;">
                    <button onclick="applyColorReplaceFromMenu()" id="applyBtn" 
                            style="flex: 1; background: var(--success); color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                            onmouseover="this.style.background='#45a049'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.2)'"
                            onmouseout="this.style.background='var(--success)'; this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)'">
                        ‚úÖ Aplicar
                    </button>
                    <button onclick="resetToOriginalImage()" 
                            style="flex: 1; background: var(--warning); color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                            onmouseover="this.style.background='#e68900'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.2)'"
                            onmouseout="this.style.background='var(--warning)'; this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)'">
                        ‚Ü©Ô∏è Original
                    </button>
                </div>
                
                <!-- Informaci√≥n -->
                <div id="menuColorReplaceInfo" style="margin-top: 12px; padding: 8px; background: var(--bg-tertiary); border-radius: 6px; font-size: 11px; color: var(--text-secondary); text-align: center;">
                    Selecciona un color origen haciendo clic en la imagen
                </div>
            `;
            
            document.body.appendChild(floatingMenu);
            
            // Hacer el men√∫ arrastrable
            makeMenuDraggable(floatingMenu);
            
            // Mostrar mensaje de bienvenida
            setTimeout(() => {
                updateMenuInfo('üëã ¬°Bienvenido! Selecciona un color origen haciendo clic en la imagen');
            }, 500);
        }

        function hideColorReplaceMenu() {
            const menu = document.getElementById('colorReplaceFloatingMenu');
            if (menu) {
                menu.style.transform = 'scale(0.8)';
                menu.style.opacity = '0';
                setTimeout(() => {
                    menu.remove();
                }, 200);
            }
        }

        function activateMouseColorPicker() {
            if (!canvas || !ctx) {
                updateMenuInfo('‚ö†Ô∏è No hay imagen cargada');
                return;
            }
            
            colorReplaceState.pickerMode = 'source';
            colorReplaceState.active = true;
            
            // Crear overlay de selecci√≥n de color en toda la imagen
            createFullImageColorSelector();
            
            updateMenuInfo('üéØ Haz clic en cualquier parte de la imagen para seleccionar el color origen');
        }

        function createFullImageColorSelector() {
            // Remover selector anterior si existe
            const existingSelector = document.getElementById('fullImageColorSelector');
            if (existingSelector) {
                existingSelector.remove();
            }
            
            // Crear overlay transparente que cubre toda la ventana
            const overlay = document.createElement('div');
            overlay.id = 'fullImageColorSelector';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.05);
                z-index: 9998;
                cursor: crosshair;
            `;
            
            document.body.appendChild(overlay);
            
            // Crear indicador de seguimiento del cursor
            const cursorIndicator = document.createElement('div');
            cursorIndicator.id = 'cursorColorIndicator';
            cursorIndicator.style.cssText = `
                position: fixed;
                width: 120px;
                height: 60px;
                background: rgba(0, 0, 0, 0.85);
                border: 2px solid #fff;
                border-radius: 8px;
                color: white;
                font-size: 10px;
                text-align: center;
                padding: 8px;
                pointer-events: none;
                z-index: 10000;
                display: none;
                box-shadow: 0 4px 16px rgba(0,0,0,0.4);
                backdrop-filter: blur(5px);
            `;
            
            cursorIndicator.innerHTML = `
                <div style="margin-bottom: 4px; font-weight: bold; font-size: 11px;">Color Actual</div>
                <div id="cursorColorPreview" style="width: 100%; height: 20px; border-radius: 4px; background: #fff; border: 1px solid #ccc; margin-bottom: 4px;"></div>
                <div id="cursorColorText" style="font-size: 9px; font-weight: bold;">#FFFFFF</div>
            `;
            
            document.body.appendChild(cursorIndicator);
            
            // Event listeners para el selector
            const handleSelectorClick = (e) => {
                // Solo procesar clics en el canvas
                const canvasRect = canvas.getBoundingClientRect();
                const x = e.clientX - canvasRect.left;
                const y = e.clientY - canvasRect.top;
                
                if (x >= 0 && y >= 0 && x < canvasRect.width && y < canvasRect.height) {
                    handleColorReplaceClick(e);
                    closeFullImageColorSelector();
                }
            };
            
            const handleSelectorMove = (e) => {
                const canvasRect = canvas.getBoundingClientRect();
                const x = e.clientX - canvasRect.left;
                const y = e.clientY - canvasRect.top;
                
                if (x >= 0 && y >= 0 && x < canvasRect.width && y < canvasRect.height) {
                    // Mostrar indicador de cursor
                    cursorIndicator.style.display = 'block';
                    cursorIndicator.style.left = (e.clientX + 15) + 'px';
                    cursorIndicator.style.top = (e.clientY - 75) + 'px';
                    
                    // Obtener color bajo el cursor
                    const dpr = window.devicePixelRatio || 1;
                    const pixelX = Math.floor(x * dpr);
                    const pixelY = Math.floor(y * dpr);
                    
                    if (pixelX >= 0 && pixelY >= 0 && pixelX < canvas.width && pixelY < canvas.height) {
                        const imageData = ctx.getImageData(pixelX, pixelY, 1, 1);
                        const [r, g, b] = imageData.data;
                        const hexColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                        
                        // Actualizar solo el cursor preview
                        const cursorPreview = document.getElementById('cursorColorPreview');
                        const cursorText = document.getElementById('cursorColorText');
                        
                        if (cursorPreview) cursorPreview.style.background = hexColor;
                        if (cursorText) cursorText.textContent = hexColor.toUpperCase();
                    }
                } else {
                    cursorIndicator.style.display = 'none';
                }
            };
            
            const handleSelectorEscape = (e) => {
                if (e.key === 'Escape') {
                    closeFullImageColorSelector();
                    updateMenuInfo('üö´ Selecci√≥n de color cancelada');
                }
            };
            
            overlay.addEventListener('click', handleSelectorClick);
            overlay.addEventListener('mousemove', handleSelectorMove);
            document.addEventListener('keydown', handleSelectorEscape);
            
            // Guardar referencias para limpieza
            overlay._handleClick = handleSelectorClick;
            overlay._handleMove = handleSelectorMove;
            overlay._handleEscape = handleSelectorEscape;
        }

        function closeFullImageColorSelector() {
            const overlay = document.getElementById('fullImageColorSelector');
            const cursorIndicator = document.getElementById('cursorColorIndicator');
            
            if (overlay) {
                // Remover event listeners
                overlay.removeEventListener('click', overlay._handleClick);
                overlay.removeEventListener('mousemove', overlay._handleMove);
                document.removeEventListener('keydown', overlay._handleEscape);
                overlay.remove();
            }
            if (cursorIndicator) cursorIndicator.remove();
            
            // Resetear estado
            colorReplaceState.pickerMode = null;
            colorReplaceState.active = false;
        }

        function createMousePickerIndicator() {
            // Remover indicador anterior
            const existingIndicator = document.getElementById('mousePickerIndicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            
            const indicator = document.createElement('div');
            indicator.id = 'mousePickerIndicator';
            indicator.style.cssText = `
                position: fixed;
                width: 160px;
                height: 80px;
                background: rgba(0, 0, 0, 0.9);
                border: 2px solid #fff;
                border-radius: 12px;
                color: white;
                font-size: 11px;
                text-align: center;
                padding: 12px;
                pointer-events: none;
                z-index: 10000;
                display: none;
                box-shadow: 0 4px 20px rgba(0,0,0,0.6);
                backdrop-filter: blur(8px);
            `;
            
            indicator.innerHTML = `
                <div style="margin-bottom: 8px; font-weight: bold; font-size: 12px;">
                    üéØ Selector de Color
                </div>
                <div id="mousePickerColorPreview" style="width: 100%; height: 24px; border-radius: 6px; background: #fff; border: 1px solid #ccc; margin-bottom: 4px;"></div>
                <div id="mousePickerColorText" style="font-size: 10px; font-weight: bold;">#FFFFFF</div>
            `;
            
            document.body.appendChild(indicator);
        }

        function showColorPaletteForTarget() {
            // Crear paleta de colores flotante
            const existingPalette = document.getElementById('targetColorPalette');
            if (existingPalette) {
                existingPalette.remove();
                return;
            }
            
            const palette = document.createElement('div');
            palette.id = 'targetColorPalette';
            palette.style.cssText = `
                position: fixed;
                left: 260px;
                top: 120px;
                background: var(--bg-secondary);
                border: 2px solid var(--border);
                border-radius: 12px;
                padding: 16px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                z-index: 1001;
                backdrop-filter: blur(10px);
                width: 280px;
            `;
            
            // Colores predefinidos
            const colors = [
                '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
                '#FF8000', '#8000FF', '#00FF80', '#FF0080', '#80FF00', '#0080FF',
                '#FF4000', '#4000FF', '#00FF40', '#FF0040', '#40FF00', '#0040FF',
                '#FF8080', '#80FF80', '#8080FF', '#FFFF80', '#FF80FF', '#80FFFF',
                '#800000', '#008000', '#000080', '#808000', '#800080', '#008080',
                '#400000', '#004000', '#000040', '#404000', '#400040', '#004040',
                '#000000', '#404040', '#808080', '#C0C0C0', '#FFFFFF', '#F0F0F0'
            ];
            
            let paletteHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                    <h3 style="margin: 0; font-size: 14px; color: var(--text-primary);">üé® Paleta de Colores</h3>
                    <button onclick="closeTargetColorPalette()" style="background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 16px; padding: 4px;">‚úï</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px;">
            `;
            
            colors.forEach(color => {
                paletteHTML += `
                    <div style="width: 32px; height: 32px; background: ${color}; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;"
                         onclick="selectTargetColor('${color}')"
                         onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.3)'"
                         onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'"
                         title="${color}">
                    </div>
                `;
            });
            
            paletteHTML += `
                </div>
                
                <!-- Color Personalizado -->
                <div style="margin-top: 12px; padding: 8px; background: var(--bg-tertiary); border-radius: 6px;">
                    <label style="display: block; font-size: 11px; color: var(--text-secondary); margin-bottom: 6px; text-align: center;">
                        üé® Color Personalizado
                    </label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="color" id="customTargetColor" value="${colorReplaceState.targetColor}" 
                               style="width: 40px; height: 32px; border: none; border-radius: 6px; cursor: pointer; background: none;"
                               onchange="selectCustomTargetColor(this.value)">
                        <div style="flex: 1; font-size: 10px; color: var(--text-secondary);">
                            Elige cualquier color
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 8px; padding: 6px; background: var(--bg-primary); border-radius: 6px; font-size: 10px; color: var(--text-secondary); text-align: center;">
                    Selecciona un color predefinido o personalizado
                </div>
            `;
            
            palette.innerHTML = paletteHTML;
            document.body.appendChild(palette);
        }

        // Funci√≥n consolidada para selecci√≥n de color destino
        function selectTargetColor(color, isCustom = false) {
            colorReplaceState.targetColor = color;
            
            const targetDisplay = document.getElementById('targetColorDisplay');
            const targetText = document.getElementById('targetColorText');
            if (targetDisplay) targetDisplay.style.background = color;
            if (targetText) targetText.textContent = color.toUpperCase();
            
            if (!isCustom) closeTargetColorPalette();
            if (colorReplaceState.sourceColor) applyInteractivePreview();
            
            updateMenuInfo(`üé® Color ${isCustom ? 'personalizado' : 'destino'} seleccionado: ${color.toUpperCase()}`);
        }

        // Alias para compatibilidad
        const selectCustomTargetColor = (color) => selectTargetColor(color, true);

        function closeTargetColorPalette() {
            const palette = document.getElementById('targetColorPalette');
            if (palette) {
                palette.remove();
            }
        }

        function updateToleranceFromSlider(value) {
            colorReplaceState.tolerance = parseInt(value);
            const display = document.getElementById('toleranceValueDisplay');
            if (display) {
                display.textContent = value;
            }
            
            // Aplicar vista previa autom√°tica si hay colores seleccionados
            if (colorReplaceState.sourceColor && colorReplaceState.targetColor) {
                applyInteractivePreview();
            }
        }

        function applyColorReplaceFromMenu() {
            if (!colorReplaceState.sourceColor) {
                updateMenuInfo('‚ö†Ô∏è Selecciona primero un color origen');
                return;
            }
            
            if (!canvas || !ctx) {
                updateMenuInfo('‚ö†Ô∏è No hay imagen cargada');
                return;
            }
            
            // Validar que los colores sean diferentes
            if (colorReplaceState.sourceColor.toLowerCase() === colorReplaceState.targetColor.toLowerCase()) {
                updateMenuInfo('‚ö†Ô∏è El color origen y destino son iguales');
                return;
            }
            
            // Guardar estado para deshacer
            saveToHistory();
            
            // Aplicar reemplazo permanente
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const processedData = processColorReplacement(imageData, true);
            ctx.putImageData(processedData, 0, 0);
            
            updateMenuInfo('‚úÖ Reemplazo aplicado correctamente');
            
            // Efecto visual de confirmaci√≥n
            const applyBtn = document.getElementById('applyBtn');
            if (applyBtn) {
                applyBtn.style.background = '#4CAF50';
                applyBtn.innerHTML = '‚úÖ ¬°Aplicado!';
                setTimeout(() => {
                    applyBtn.style.background = 'var(--success)';
                    applyBtn.innerHTML = '‚úÖ Aplicar';
                }, 1500);
            }
        }

        function resetToOriginalImage() {
            if (colorReplaceState.originalImageData && ctx) {
                ctx.putImageData(colorReplaceState.originalImageData, 0, 0);
                updateMenuInfo('‚Ü©Ô∏è Imagen restaurada al estado original');
            }
        }

        function applyInteractivePreview() {
            if (!canvas || !ctx || !colorReplaceState.sourceColor || !colorReplaceState.originalImageData) {
                return;
            }
            
            // Aplicar vista previa temporal
            const imageData = new ImageData(
                new Uint8ClampedArray(colorReplaceState.originalImageData.data),
                colorReplaceState.originalImageData.width,
                colorReplaceState.originalImageData.height
            );
            
            const processedData = processColorReplacement(imageData, false);
            ctx.putImageData(processedData, 0, 0);
            
            updateMenuInfo('üîç Vista previa activa - Mueve la tolerancia para ajustar');
            
            // A√±adir indicador visual de vista previa
            showPreviewIndicator();
        }

        function showPreviewIndicator() {
            // Remover indicador previo
            const existingIndicator = document.getElementById('previewIndicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            
            const indicator = document.createElement('div');
            indicator.id = 'previewIndicator';
            indicator.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 12px;
                font-weight: bold;
                z-index: 9999;
                box-shadow: 0 4px 16px rgba(0,0,0,0.3);
                animation: previewPulse 2s infinite;
                backdrop-filter: blur(10px);
            `;
            
            indicator.innerHTML = 'üîç VISTA PREVIA - Los cambios no son permanentes';
            document.body.appendChild(indicator);
            
            // Auto-remover despu√©s de 3 segundos
            setTimeout(() => {
                if (indicator && indicator.parentNode) {
                    indicator.style.opacity = '0';
                    indicator.style.transform = 'translateX(-50%) scale(0.8)';
                    setTimeout(() => {
                        indicator.remove();
                    }, 300);
                }
            }, 3000);
        }

        // updateMenuInfo consolidada con updateColorReplaceInfo
        const updateMenuInfo = updateColorReplaceInfo;

        function makeMenuDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            const header = element.querySelector('h3');
            if (header) {
                header.style.cursor = 'move';
                header.onmousedown = dragMouseDown;
            }
            
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        function showColorReplaceHelp() {
            // Crear panel de ayuda
            const existingHelp = document.getElementById('colorReplaceHelp');
            if (existingHelp) {
                existingHelp.remove();
                return;
            }
            
            const helpPanel = document.createElement('div');
            helpPanel.id = 'colorReplaceHelp';
            helpPanel.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 2px solid var(--border);
                border-radius: 12px;
                padding: 20px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.4);
                z-index: 10001;
                max-width: 400px;
                backdrop-filter: blur(10px);
                animation: colorReplaceMenuFadeIn 0.3s ease-out;
            `;
            
            helpPanel.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                    <h3 style="margin: 0; font-size: 16px; color: var(--text-primary);">üé® Gu√≠a de Reemplazo de Color</h3>
                    <button onclick="closeColorReplaceHelp()" style="background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 18px; padding: 4px;">‚úï</button>
                </div>
                
                <div style="color: var(--text-secondary); font-size: 13px; line-height: 1.6;">
                    <div style="margin-bottom: 12px;">
                        <strong style="color: var(--text-primary);">üéØ Seleccionar Color Origen:</strong><br>
                        ‚Ä¢ Haz clic en el cuadro de color origen<br>
                        ‚Ä¢ Luego haz clic en cualquier parte de la imagen
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <strong style="color: var(--text-primary);">üé® Elegir Color Destino:</strong><br>
                        ‚Ä¢ Haz clic en el cuadro de color destino<br>
                        ‚Ä¢ Selecciona un color predefinido de la paleta<br>
                        ‚Ä¢ O usa el selector de "Color Personalizado"
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <strong style="color: var(--text-primary);">üéöÔ∏è Tolerancia:</strong><br>
                        ‚Ä¢ 0% = Solo el color exacto<br>
                        ‚Ä¢ 50% = Colores similares<br>
                        ‚Ä¢ 100% = Rango muy amplio
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <strong style="color: var(--text-primary);">‚ö° Atajos:</strong><br>
                        ‚Ä¢ <kbd>L</kbd> = Activar herramienta<br>
                        ‚Ä¢ <kbd>Ctrl+Z</kbd> = Deshacer<br>
                        ‚Ä¢ <kbd>Escape</kbd> = Cancelar selecci√≥n
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <strong style="color: var(--text-primary);">üí° Consejos:</strong><br>
                        ‚Ä¢ La vista previa es autom√°tica<br>
                        ‚Ä¢ Usa tolerancia baja para precisi√≥n<br>
                        ‚Ä¢ Puedes arrastrar este men√∫
                    </div>
                </div>
            `;
            
            document.body.appendChild(helpPanel);
            
            // Auto-cerrar despu√©s de 15 segundos
            setTimeout(() => {
                if (helpPanel && helpPanel.parentNode) {
                    helpPanel.remove();
                }
            }, 15000);
        }

        function closeColorReplaceHelp() {
            const helpPanel = document.getElementById('colorReplaceHelp');
            if (helpPanel) {
                helpPanel.remove();
            }
        }

        function activateColorPickerMode(mode) {
            colorReplaceState.pickerMode = mode;
            colorReplaceState.active = true;
            
            if (canvas) {
                canvas.style.cursor = 'crosshair';
            }
            
            updateColorReplaceInfo(`Haz clic en la imagen para seleccionar el color ${mode === 'source' ? 'origen' : 'destino'}`);
            
            // Crear indicador visual
            createColorPickerIndicator();
        }

        function createColorPickerIndicator() {
            // Remover indicador anterior
            const existingIndicator = document.getElementById('colorPickerIndicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            
            const indicator = document.createElement('div');
            indicator.id = 'colorPickerIndicator';
            indicator.style.cssText = `
                position: fixed;
                width: 120px;
                height: 60px;
                background: rgba(0, 0, 0, 0.9);
                border: 2px solid #fff;
                border-radius: 8px;
                color: white;
                font-size: 11px;
                text-align: center;
                padding: 8px;
                pointer-events: none;
                z-index: 10000;
                display: none;
                box-shadow: 0 4px 15px rgba(0,0,0,0.5);
                backdrop-filter: blur(5px);
            `;
            
            indicator.innerHTML = `
                <div style="margin-bottom: 4px; font-weight: bold;">
                    ${colorReplaceState.pickerMode === 'source' ? 'üéØ Color Origen' : 'üé® Color Destino'}
                </div>
                <div id="pickerColorPreview" style="width: 100%; height: 20px; border-radius: 4px; background: #fff; border: 1px solid #ccc;"></div>
                <div style="margin-top: 4px; font-size: 9px;">Clic para seleccionar</div>
            `;
            
            document.body.appendChild(indicator);
        }

        function updateColorReplaceSource(color) {
            colorReplaceState.sourceColor = color;
            updateColorReplaceInfo(`Color origen: ${color.toUpperCase()}`);
            
            if (colorReplaceState.previewMode) {
                generateColorReplacePreview();
            }
        }

        function updateColorReplaceTarget(color) {
            colorReplaceState.targetColor = color;
            updateColorReplaceInfo(`Color destino: ${color.toUpperCase()}`);
            
            if (colorReplaceState.previewMode) {
                generateColorReplacePreview();
            }
        }

        function updateColorReplaceTolerance(value) {
            colorReplaceState.tolerance = parseInt(value);
            document.getElementById('colorReplaceToleranceValue').textContent = value;
            
            if (colorReplaceState.previewMode) {
                generateColorReplacePreview();
            }
        }

        function updateColorReplaceMode(mode) {
            colorReplaceState.mode = mode;
            
            if (colorReplaceState.previewMode) {
                generateColorReplacePreview();
            }
        }

        // Funci√≥n consolidada para actualizar info de reemplazo de color
        function updateColorReplaceInfo(message) {
            ['colorReplaceInfo', 'menuColorReplaceInfo'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.innerHTML = message;
            });
        }

        function toggleColorReplacePreview() {
            const button = document.getElementById('colorReplacePreviewBtn');
            
            if (!colorReplaceState.previewMode) {
                // Activar vista previa
                colorReplaceState.previewMode = true;
                button.textContent = 'üëÅÔ∏è Desactivar Vista Previa';
                button.style.background = 'var(--warning)';
                
                if (colorReplaceState.sourceColor) {
                    generateColorReplacePreview();
                } else {
                    updateColorReplaceInfo('‚ö†Ô∏è Selecciona primero un color origen');
                }
            } else {
                // Desactivar vista previa
                clearColorReplacePreview();
                button.textContent = 'üëÅÔ∏è Activar Vista Previa';
                button.style.background = '';
                colorReplaceState.previewMode = false;
            }
        }

        function generateColorReplacePreview() {
            if (!canvas || !ctx || !colorReplaceState.sourceColor || !colorReplaceState.originalImageData) {
                return;
            }
            
            // Aplicar reemplazo temporal
            const imageData = new ImageData(
                new Uint8ClampedArray(colorReplaceState.originalImageData.data),
                colorReplaceState.originalImageData.width,
                colorReplaceState.originalImageData.height
            );
            
            const processedData = processColorReplacement(imageData, false);
            ctx.putImageData(processedData, 0, 0);
            
            updateColorReplaceInfo('üîç Vista previa activa - Los cambios no son permanentes');
        }

        function clearColorReplacePreview() {
            if (colorReplaceState.originalImageData && ctx) {
                ctx.putImageData(colorReplaceState.originalImageData, 0, 0);
            }
        }

        function applyColorReplace() {
            if (!colorReplaceState.sourceColor) {
                updateColorReplaceInfo('‚ö†Ô∏è Selecciona primero un color origen');
                return;
            }
            
            if (!canvas || !ctx) {
                updateColorReplaceInfo('‚ö†Ô∏è No hay imagen cargada');
                return;
            }
            
            // Guardar estado para deshacer ANTES de aplicar el reemplazo
            saveToHistory();
            
            // Aplicar reemplazo permanente
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const processedData = processColorReplacement(imageData, true);
            ctx.putImageData(processedData, 0, 0);
            
            updateColorReplaceInfo('‚úÖ Reemplazo de color aplicado correctamente');
            
            // Desactivar vista previa
            if (colorReplaceState.previewMode) {
                toggleColorReplacePreview();
            }
        }

        function processColorReplacement(imageData, isPermanent) {
            const data = imageData.data;
            const sourceColor = hexToRgb(colorReplaceState.sourceColor);
            const targetColor = hexToRgb(colorReplaceState.targetColor);
            const tolerance = colorReplaceState.tolerance;
            
            // Validar que los colores sean v√°lidos
            if (!sourceColor || !targetColor) {
                return imageData;
            }
            
            let replacedPixels = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                // Calcular distancia de color usando f√≥rmula euclidiana mejorada
                const distance = Math.sqrt(
                    Math.pow(r - sourceColor.r, 2) +
                    Math.pow(g - sourceColor.g, 2) +
                    Math.pow(b - sourceColor.b, 2)
                );
                
                // Convertir tolerancia de porcentaje a valor m√°s suave (0-441 max distance)
                const maxDistance = tolerance * 4.41; // M√°s rango para mayor suavidad
                
                if (distance <= maxDistance) {
                    replacedPixels++;
                    
                    // Aplicar reemplazo ultra suave basado en la distancia
                    if (tolerance > 0) {
                        // Factor de suavidad m√°s progresivo
                        const factor = 1 - (distance / maxDistance);
                        // Curva suave exponencial para transici√≥n m√°s natural
                        const ultraSmoothFactor = Math.pow(factor, 1.5) * Math.pow(Math.sin(factor * Math.PI / 2), 0.8);
                        
                        // Interpolaci√≥n suave entre colores
                        data[i] = Math.round(r + (targetColor.r - r) * ultraSmoothFactor);
                        data[i + 1] = Math.round(g + (targetColor.g - g) * ultraSmoothFactor);
                        data[i + 2] = Math.round(b + (targetColor.b - b) * ultraSmoothFactor);
                    } else {
                        // Reemplazo exacto para tolerancia 0
                        data[i] = targetColor.r;
                        data[i + 1] = targetColor.g;
                        data[i + 2] = targetColor.b;
                    }
                }
            }
            
            if (isPermanent) {
                updateMenuInfo(`‚úÖ ${replacedPixels} p√≠xeles reemplazados con √©xito`);
            }
            
            return imageData;
        }

        // Funciones auxiliares para conversi√≥n de color
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            return {h: h, s: s, l: l};
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        // Manejar clics en el canvas para la herramienta de reemplazo de color
        function handleColorReplaceClick(event) {
            if (appState.currentTool !== 'colorReplace' || !colorReplaceState.pickerMode) {
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Ajustar por el ratio de p√≠xeles del dispositivo
            const dpr = window.devicePixelRatio || 1;
            const pixelX = Math.floor(x * dpr);
            const pixelY = Math.floor(y * dpr);
            
            // Obtener color del p√≠xel
            const imageData = ctx.getImageData(pixelX, pixelY, 1, 1);
            const [r, g, b] = imageData.data;
            const hexColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            
            // Actualizar el color seleccionado en el men√∫ flotante
            if (colorReplaceState.pickerMode === 'source') {
                colorReplaceState.sourceColor = hexColor;
                
                // Actualizar el display del men√∫
                const sourceDisplay = document.getElementById('sourceColorDisplay');
                const sourceText = document.getElementById('sourceColorText');
                
                if (sourceDisplay) {
                    sourceDisplay.style.background = hexColor;
                }
                if (sourceText) {
                    sourceText.textContent = hexColor.toUpperCase();
                }
                
                updateMenuInfo(`üéØ Color origen seleccionado: ${hexColor.toUpperCase()}`);
                
                // Aplicar vista previa autom√°tica si hay color destino
                if (colorReplaceState.targetColor) {
                    applyInteractivePreview();
                }
            }
            
            // Desactivar modo selector
            colorReplaceState.pickerMode = null;
            colorReplaceState.active = false;
            
            // Remover indicador del mouse picker
            const indicator = document.getElementById('mousePickerIndicator');
            if (indicator) {
                indicator.remove();
            }
            
            // Cerrar selector de imagen completa si est√° activo
            closeFullImageColorSelector();
            
            // Restaurar cursor
            if (canvas) {
                canvas.style.cursor = 'crosshair';
            }
        }

                 // Manejar movimiento del mouse para el indicador
        function handleColorReplaceMouseMove(event) {
            if (appState.currentTool !== 'colorReplace' || !colorReplaceState.pickerMode) {
                return;
            }
            
            const indicator = document.getElementById('mousePickerIndicator');
            if (!indicator) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Obtener color actual bajo el cursor
            const dpr = window.devicePixelRatio || 1;
            const pixelX = Math.floor(x * dpr);
            const pixelY = Math.floor(y * dpr);
            
            if (pixelX >= 0 && pixelY >= 0 && pixelX < canvas.width && pixelY < canvas.height) {
                const imageData = ctx.getImageData(pixelX, pixelY, 1, 1);
                const [r, g, b] = imageData.data;
                const hexColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                
                // Actualizar preview del color
                const preview = document.getElementById('mousePickerColorPreview');
                const colorText = document.getElementById('mousePickerColorText');
                
                if (preview) {
                    preview.style.background = hexColor;
                }
                if (colorText) {
                    colorText.textContent = hexColor.toUpperCase();
                }
                
                // Posicionar indicador
                indicator.style.left = (event.clientX + 15) + 'px';
                indicator.style.top = (event.clientY - 85) + 'px';
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }

        // ========================================
        // FUNCIONES AVANZADAS SORPRENDENTES
        // ========================================

        function activateMagicWand() {
            if (!canvas || !ctx) {
                updateColorReplaceInfo('‚ö†Ô∏è No hay imagen cargada');
                return;
            }
            
            updateColorReplaceInfo('ü™Ñ Varita M√°gica activada - Haz clic en cualquier parte de la imagen');
            
            // Crear overlay especial para varita m√°gica
            const magicOverlay = document.createElement('div');
            magicOverlay.id = 'magicWandOverlay';
            magicOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.3);
                z-index: 9999;
                cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><text y="20" font-size="20">ü™Ñ</text></svg>'), auto;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 18px;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            `;
            
            magicOverlay.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 20px;">ü™Ñ‚ú®</div>
                    <div>Haz clic en cualquier color para seleccionar autom√°ticamente</div>
                    <div style="font-size: 14px; margin-top: 10px;">todos los colores similares en la imagen</div>
                    <div style="font-size: 12px; margin-top: 10px; opacity: 0.8;">Presiona Escape para cancelar</div>
                </div>
            `;
            
            document.body.appendChild(magicOverlay);
            
            // Event listeners para varita m√°gica
            const magicWandClick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (x >= 0 && y >= 0 && x < canvas.offsetWidth && y < canvas.offsetHeight) {
                    performMagicWandSelection(x, y);
                    magicOverlay.remove();
                    document.removeEventListener('click', magicWandClick);
                    document.removeEventListener('keydown', magicWandEscape);
                }
            };
            
            const magicWandEscape = (e) => {
                if (e.key === 'Escape') {
                    magicOverlay.remove();
                    document.removeEventListener('click', magicWandClick);
                    document.removeEventListener('keydown', magicWandEscape);
                    updateColorReplaceInfo('ü™Ñ Varita M√°gica cancelada');
                }
            };
            
            document.addEventListener('click', magicWandClick);
            document.addEventListener('keydown', magicWandEscape);
        }

        function performMagicWandSelection(x, y) {
            const dpr = window.devicePixelRatio || 1;
            const pixelX = Math.floor(x * dpr);
            const pixelY = Math.floor(y * dpr);
            
            // Obtener color del p√≠xel seleccionado
            const imageData = ctx.getImageData(pixelX, pixelY, 1, 1);
            const [r, g, b] = imageData.data;
            const selectedColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            
            // Aplicar selecci√≥n autom√°tica
            document.getElementById('colorReplaceSource').value = selectedColor;
            colorReplaceState.sourceColor = selectedColor;
            
            // Calcular estad√≠sticas autom√°ticamente
            const stats = calculateColorStatistics(selectedColor);
            
            // Mostrar panel de estad√≠sticas
            document.getElementById('colorStatsPanel').style.display = 'block';
            updateColorStatsDisplay(stats);
            
            // Generar colores sugeridos autom√°ticamente
            const suggestedColors = generateColorSuggestions(selectedColor);
            showColorSuggestions(suggestedColors);
            
            updateColorReplaceInfo(`ü™Ñ ¬°Varita M√°gica! Seleccionado: ${selectedColor.toUpperCase()} - ${stats.matchingPixels} p√≠xeles encontrados`);
            
            // Activar vista previa autom√°ticamente
            if (!colorReplaceState.previewMode) {
                toggleColorReplacePreview();
            }
        }

        function calculateColorStatistics(color) {
            if (!canvas || !ctx) return { matchingPixels: 0, percentage: 0, uniqueColors: 0, areaSize: 0 };
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const sourceColor = hexToRgb(color);
            const tolerance = colorReplaceState.tolerance;
            
            let matchingPixels = 0;
            const uniqueColors = new Set();
            const totalPixels = imageData.width * imageData.height;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Agregar color √∫nico
                const colorKey = `${r},${g},${b}`;
                uniqueColors.add(colorKey);
                
                // Verificar coincidencia
                const distance = Math.sqrt(
                    Math.pow(r - sourceColor.r, 2) +
                    Math.pow(g - sourceColor.g, 2) +
                    Math.pow(b - sourceColor.b, 2)
                );
                
                if (distance <= tolerance * 2.55) {
                    matchingPixels++;
                }
            }
            
            return {
                matchingPixels,
                percentage: ((matchingPixels / totalPixels) * 100).toFixed(2),
                uniqueColors: uniqueColors.size,
                areaSize: matchingPixels
            };
        }

        function updateColorStatsDisplay(stats) {
            document.getElementById('matchingPixels').textContent = stats.matchingPixels.toLocaleString();
            document.getElementById('imagePercentage').textContent = stats.percentage + '%';
            document.getElementById('uniqueColors').textContent = stats.uniqueColors.toLocaleString();
            document.getElementById('areaSize').textContent = stats.areaSize.toLocaleString() + ' px¬≤';
        }

        function updateColorStatsRealTime(hoveredColor) {
            if (colorReplaceState.sourceColor) {
                const stats = calculateColorStatistics(hoveredColor);
                updateColorStatsDisplay(stats);
            }
        }

        function showColorHistogram() {
            const statsPanel = document.getElementById('colorStatsPanel');
            if (statsPanel.style.display === 'none') {
                statsPanel.style.display = 'block';
                
                if (colorReplaceState.sourceColor) {
                    const stats = calculateColorStatistics(colorReplaceState.sourceColor);
                    updateColorStatsDisplay(stats);
                }
                
                updateColorReplaceInfo('üìä Panel de estad√≠sticas activado');
            } else {
                statsPanel.style.display = 'none';
                updateColorReplaceInfo('üìä Panel de estad√≠sticas oculto');
            }
        }

        function generateColorSuggestions(baseColor) {
            const rgb = hexToRgb(baseColor);
            const suggestions = [];
            
            // Colores complementarios
            suggestions.push(rgbToHex(255 - rgb.r, 255 - rgb.g, 255 - rgb.b));
            
            // Colores an√°logos
            const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
            for (let i = 1; i <= 3; i++) {
                const newHue = (hsl.h + i * 0.1) % 1;
                const analogous = hslToRgb(newHue, hsl.s, hsl.l);
                suggestions.push(rgbToHex(analogous.r, analogous.g, analogous.b));
            }
            
            // Tonos m√°s claros y oscuros
            for (let i = 0.3; i <= 0.9; i += 0.3) {
                const lighter = hslToRgb(hsl.h, hsl.s, Math.min(1, hsl.l + i * 0.3));
                const darker = hslToRgb(hsl.h, hsl.s, Math.max(0, hsl.l - i * 0.3));
                suggestions.push(rgbToHex(lighter.r, lighter.g, lighter.b));
                suggestions.push(rgbToHex(darker.r, darker.g, darker.b));
            }
            
            return suggestions.slice(0, 8); // Limitar a 8 sugerencias
        }

        function showColorSuggestions(colors) {
            // Crear panel de sugerencias si no existe
            let suggestionsPanel = document.getElementById('colorSuggestions');
            if (!suggestionsPanel) {
                suggestionsPanel = document.createElement('div');
                suggestionsPanel.id = 'colorSuggestions';
                suggestionsPanel.style.cssText = `
                    position: fixed;
                    top: 50%;
                    right: 20px;
                    transform: translateY(-50%);
                    background: var(--bg-secondary);
                    border: 2px solid var(--border);
                    border-radius: 8px;
                    padding: 15px;
                    z-index: 10000;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    max-width: 200px;
                `;
                document.body.appendChild(suggestionsPanel);
            }
            
            suggestionsPanel.innerHTML = `
                <div style="margin-bottom: 10px; font-weight: bold; color: var(--text-primary);">
                    ‚ú® Colores Sugeridos
                </div>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                    ${colors.map(color => `
                        <div 
                            style="width: 30px; height: 30px; background: ${color}; border-radius: 4px; cursor: pointer; border: 2px solid var(--border); transition: transform 0.2s;"
                            title="${color.toUpperCase()}"
                            onclick="selectSuggestedColor('${color}')"
                            onmouseover="this.style.transform='scale(1.1)'"
                            onmouseout="this.style.transform='scale(1)'"
                        ></div>
                    `).join('')}
                </div>
                <button onclick="closeSuggestions()" style="margin-top: 10px; width: 100%; padding: 5px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary); cursor: pointer;">
                    Cerrar
                </button>
            `;
            
            // Auto-cerrar despu√©s de 15 segundos
            setTimeout(() => {
                if (suggestionsPanel && suggestionsPanel.parentNode) {
                    suggestionsPanel.remove();
                }
            }, 15000);
        }

        function selectSuggestedColor(color) {
            document.getElementById('colorReplaceTarget').value = color;
            colorReplaceState.targetColor = color;
            
            if (colorReplaceState.previewMode) {
                generateColorReplacePreview();
            }
            
            updateColorReplaceInfo(`‚ú® Color sugerido aplicado: ${color.toUpperCase()}`);
            
            // Cerrar panel de sugerencias
            closeSuggestions();
        }

        function closeSuggestions() {
            const panel = document.getElementById('colorSuggestions');
            if (panel) {
                panel.remove();
            }
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // Mapas de configuraci√≥n para herramientas
        const toolCursors = {
            colorReplace: 'crosshair', brush: 'crosshair', eyedropper: 'crosshair',
            eraser: 'grab', zoom: 'zoom-in'
        };
        const toolNames = {
            colorReplace: 'üé®üîÑ Reemplazo de Color', brush: 'üñåÔ∏è Pincel', eraser: 'üßΩ Borrador',
            eyedropper: 'üíß Cuentagotas', zoom: 'üîç Zoom', select: 'üîß Seleccionar'
        };

        function updateCanvasCursor(toolName) {
            if (canvas) canvas.style.cursor = toolCursors[toolName] || 'default';
        }

        function updateCurrentToolInfo(toolName) {
            const toolInfo = document.getElementById('currentTool');
            if (toolInfo) toolInfo.textContent = toolNames[toolName] || 'üîß ' + toolName;
        }



        // Funci√≥n optimizada para limpiar estados cuando se cambia de herramienta
        function cleanupToolStates() {
            if (colorReplaceState.previewMode) {
                clearColorReplacePreview();
                colorReplaceState.previewMode = false;
            }
            
            // Eliminar todos los elementos flotantes de una vez
            ['colorReplaceFloatingMenu', 'targetColorPalette', 'mousePickerIndicator',
             'colorPickerIndicator', 'colorSuggestions', 'previewIndicator',
             'colorReplaceHelp', 'fullImageColorSelector', 'cursorColorIndicator'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.remove();
            });
            
            colorReplaceState.pickerMode = null;
            colorReplaceState.active = false;
        }



        // Funci√≥n consolidada de notificaciones
        function createNotification(options) {
            const { message, bg, color, duration = 3000 } = options;
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 20px; right: 20px;
                padding: 10px 15px; border-radius: 8px;
                font-size: 13px; font-weight: 500; z-index: 10001;
                box-shadow: 0 4px 15px rgba(0,0,0,0.2);
                animation: slideIn 0.3s ease; pointer-events: none;
                background: ${bg}; color: ${color};
            `;
            notification.innerHTML = message;
            document.body.appendChild(notification);
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease forwards';
                setTimeout(() => notification.parentNode?.removeChild(notification), 300);
            }, duration);
        }

        const notificationColors = { success: '#4CAF50', error: '#f44336', info: '#2196F3' };
        
        function showNotification(message, type = 'info') {
            createNotification({ message, bg: notificationColors[type], color: 'white' });
        }

        function showColorNotification(hexColor) {
            createNotification({
                message: `üíß Color seleccionado: ${hexColor.toUpperCase()}`,
                bg: hexColor,
                color: isLightColor(hexColor) ? '#000' : '#fff',
                duration: 2000
            });
        }

        function isLightColor(hexColor) {
            // Convertir hex a RGB
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            
            // Calcular luminancia
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Mapa de nombres de herramientas para la barra de estado
        const toolDisplayNames = {
            select: 'Seleccionar', crop: 'Recortar', brush: 'Pincel', eraser: 'Borrador',
            text: 'Texto', arrow: 'Flecha', gradient: 'Gradiente', eyedropper: 'Cuentagotas',
            clone: 'Clonar', heal: 'Reparar', zoom: 'Zoom', shape: 'Formas'
        };
        const getToolDisplayName = (tool) => toolDisplayNames[tool] || tool;

        function updateStatusBar() {
            const file = imageState.currentFile;
            const dpr = window.devicePixelRatio || 1;
            
            if (domElements.filePathInfo) {
                domElements.filePathInfo.textContent = file 
                    ? `üìÅ ${file.webkitRelativePath?.replace(/[^\/]*$/, '') || 'D:\\'}${file.name}`
                    : 'üìÅ Nueva imagen';
            }
            
            if (domElements.imageDimensions && canvas) {
                const w = imageState.originalImage?.width || Math.round(canvas.width / dpr);
                const h = imageState.originalImage?.height || Math.round(canvas.height / dpr);
                domElements.imageDimensions.textContent = `üìê ${w} √ó ${h} p√≠xeles`;
            }
            
            if (domElements.fileSizeInfo)
                domElements.fileSizeInfo.textContent = file ? `üì¶ ${formatFileSize(file.size)}` : 'üì¶ -';
            if (domElements.zoomLevel)
                domElements.zoomLevel.textContent = `üîç ${Math.round(appState.zoomLevel * 100)}%`;
            if (domElements.currentTool)
                domElements.currentTool.textContent = `üîß ${getToolDisplayName(appState.currentTool)}`;
        }

        function updateMousePosition(x, y) {
            if (domElements.mousePos) domElements.mousePos.textContent = `üñ±Ô∏è x: ${Math.round(x)}, y: ${Math.round(y)}`;
        }

        function updatePixelInfo(x, y) {
            // Solo bloquear si no es el eyedropper el que est√° activo
            if (!domElements.pixelInfo || !canvas || !ctx || (appState.lockStatusBarColor && !appState.eyedropperActive)) return;
            
            try {
                const dpr = window.devicePixelRatio || 1;
                const canvasX = Math.floor(x * dpr);
                const canvasY = Math.floor(y * dpr);
                
                if (canvasX >= 0 && canvasY >= 0 && canvasX < canvas.width && canvasY < canvas.height) {
                    const imageData = ctx.getImageData(canvasX, canvasY, 1, 1);
                    const data = imageData.data;
                    const r = data[0];
                    const g = data[1];
                    const b = data[2];
                    const a = data[3];
                    
                    // Crear color hex
                    const hexColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                    
                    // Mostrar informaci√≥n completa con estilo especial si el eyedropper est√° activo
                    if (appState.eyedropperActive) {
                        domElements.pixelInfo.innerHTML = `üé® <strong>RGB: ${r}, ${g}, ${b} | ${hexColor.toUpperCase()}</strong>`;
                        domElements.pixelInfo.style.color = '#4CAF50';
                        domElements.pixelInfo.style.fontWeight = 'bold';
                        
                    } else {
                        domElements.pixelInfo.innerHTML = `üé® RGB: ${r}, ${g}, ${b} | ${hexColor.toUpperCase()}`;
                        domElements.pixelInfo.style.color = '';
                        domElements.pixelInfo.style.fontWeight = '';
                    }
                } else {
                    domElements.pixelInfo.textContent = 'üé® RGB: -, -, -';
                    domElements.pixelInfo.style.color = '';
                    domElements.pixelInfo.style.fontWeight = '';
                }
            } catch (error) {
                domElements.pixelInfo.textContent = 'üé® RGB: -, -, -';
                domElements.pixelInfo.style.color = '';
                domElements.pixelInfo.style.fontWeight = '';
            }
        }

        function updateHistogram() {
            if (!domElements.histogramCanvas || !canvas) return;
            
            const histCtx = domElements.histogramCanvas.getContext('2d');
            histCtx.clearRect(0, 0, domElements.histogramCanvas.width, domElements.histogramCanvas.height);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            const histogram = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
            for (let i = 0; i < data.length; i += 4) {
                histogram.r[data[i]]++;
                histogram.g[data[i + 1]]++;
                histogram.b[data[i + 2]]++;
            }
            
            const maxValue = Math.max(...histogram.r, ...histogram.g, ...histogram.b);
            if (maxValue === 0) return;
            
            const width = domElements.histogramCanvas.width;
            const height = domElements.histogramCanvas.height;
            histCtx.globalAlpha = 0.7;
            
            const drawChannel = (channel, color) => {
                histCtx.fillStyle = color;
                for (let i = 0; i < 256; i++) {
                    const barHeight = (histogram[channel][i] / maxValue) * height;
                    if (barHeight > 0) histCtx.fillRect((i / 255) * width, height - barHeight, 1, barHeight);
                }
            };
            
            drawChannel('r', '#ff4444');
            drawChannel('g', '#44ff44');
            drawChannel('b', '#4444ff');
        }



        // =================================================================================
        // SECTION: SETTINGS MANAGEMENT
        // =================================================================================

        function loadSettings() {
            const saved = localStorage.getItem('editorSettings');
            if (saved) {
                try {
                    appSettings = { ...defaultSettings, ...JSON.parse(saved) };
                } catch (e) {
                    appSettings = { ...defaultSettings };
                }
            }
            applySettings();
        }

        function saveSettings() {
            appSettings.canvas.size = domElements.defaultCanvasSize.value;
            appSettings.canvas.width = parseInt(domElements.customWidth.value) || 1920;
            appSettings.canvas.height = parseInt(domElements.customHeight.value) || 1080;
            appSettings.canvas.backgroundColor = domElements.defaultBackgroundColor.value;
            
            appSettings.tools.defaultTool = domElements.defaultTool.value;
            appSettings.tools.color = domElements.defaultToolColor.value;
            appSettings.tools.thickness = parseInt(domElements.defaultThickness.value);
            appSettings.tools.fontSize = parseInt(domElements.defaultFontSize.value);
            
            appSettings.performance.renderQuality = domElements.renderQuality.value;
            appSettings.performance.historyLimit = parseInt(domElements.historyLimit.value);
            appSettings.performance.autoSave = domElements.autoSave.checked;
            
            appSettings.ui.theme = domElements.defaultTheme.value;
            appSettings.ui.showTooltips = domElements.showTooltips.checked;
            appSettings.ui.enableAnimations = domElements.enableAnimations.checked;

            if (appSettings.performance.autoSave) {
                localStorage.setItem('editorSettings', JSON.stringify(appSettings));
            }
            
            applySettings();
            closeModal('settingsModal');
        }

        function applySettings() {
            document.body.dataset.theme = appSettings.ui.theme;
            toolSettings.currentColor = appSettings.tools.color;
            toolSettings.globalThickness = appSettings.tools.thickness;
            toolSettings.text.size = appSettings.tools.fontSize;
            document.querySelectorAll('.tooltip').forEach(tooltip => {
                tooltip.style.display = appSettings.ui.showTooltips ? 'block' : 'none';
            });
            updateAllToolPropertiesUI();
        }

        function resetToDefaults() {
            appSettings = { ...defaultSettings };
            updateSettingsModal();
        }

        function updateSettingsModal() {
            domElements.defaultCanvasSize.value = appSettings.canvas.size;
            domElements.customWidth.value = appSettings.canvas.width;
            domElements.customHeight.value = appSettings.canvas.height;
            domElements.defaultBackgroundColor.value = appSettings.canvas.backgroundColor;
            
            domElements.defaultTool.value = appSettings.tools.defaultTool;
            domElements.defaultToolColor.value = appSettings.tools.color;
            domElements.defaultThickness.value = appSettings.tools.thickness;
            domElements.defaultFontSize.value = appSettings.tools.fontSize;
            
            domElements.renderQuality.value = appSettings.performance.renderQuality;
            domElements.historyLimit.value = appSettings.performance.historyLimit;
            domElements.autoSave.checked = appSettings.performance.autoSave;
            
            domElements.defaultTheme.value = appSettings.ui.theme;
            domElements.showTooltips.checked = appSettings.ui.showTooltips;
            domElements.enableAnimations.checked = appSettings.ui.enableAnimations;
            
            updateCanvasSizePreview();
            updateSliderUI('defaultThickness', appSettings.tools.thickness);
            updateSliderUI('defaultFontSize', appSettings.tools.fontSize);
        }

        function updateCanvasSizePreview() {
            const sizeType = domElements.defaultCanvasSize.value;
            let width, height, text;
            
            const sizeMap = {
                fullscreen: () => {
                    const w = window.screen.width, h = window.screen.height;
                    return [Math.min(w - 100, 1920), Math.min(h - 200, 1080), `Pantalla completa`];
                },
                hd: () => [1920, 1080, `Full HD`],
                '4k': () => [3840, 2160, `4K UHD`],
                'square-lg': () => [1080, 1080, `Cuadrado grande`],
                'square-md': () => [800, 800, `Cuadrado mediano`],
                a4: () => [794, 1123, `A4 - 96 DPI`],
                custom: () => [parseInt(domElements.customWidth.value) || 1920, parseInt(domElements.customHeight.value) || 1080, `Personalizado`]
            };

            [width, height, text] = sizeMap[sizeType]();
            domElements.canvasSizePreview.textContent = `Vista previa: ${width} √ó ${height} p√≠xeles (${text})`;
            domElements.customSizeControls.style.display = sizeType === 'custom' ? 'block' : 'none';
        }

        function setBackgroundColor(color) {
            domElements.defaultBackgroundColor.value = color === 'transparent' ? '#FFFFFF' : color;
        }

        function showSettingsModal() {
            domElements.settingsModal.style.display = 'flex';
            updateSettingsModal();
        }
    
        function initializeModernFeatures() {
            if (domElements.modernApiIndicator) {
                domElements.modernApiIndicator.style.display = window.showSaveFilePicker ? 'inline' : 'none';
            }
        }
    </script>
    <script>
        function togglePanel(panelTitle) {
            const panelSection = panelTitle.closest('.panel-section');
            if (panelSection) {
                panelSection.classList.toggle('collapsed');
            }
        }

                 // Collapse all panels by default on load
         document.addEventListener('DOMContentLoaded', () => {
             const panelTitles = document.querySelectorAll('.properties-panel .panel-title');
             panelTitles.forEach((title, index) => {
                 const panelSection = title.closest('.panel-section');
                 if (panelSection) { // Collapse ALL panels by default
                     panelSection.classList.add('collapsed');
                 }
             });
         });

         // Function to open Tool Properties panel when a tool is selected
         function openToolPropertiesPanel() {
             const toolPropertiesSection = document.getElementById('toolProperties');
             if (toolPropertiesSection) {
                 toolPropertiesSection.classList.remove('collapsed');
             }
         }

         // Function to show only relevant tool properties
         function showToolProperties(toolType) {
             // Hide all tool property groups first
             const allToolProperties = document.querySelectorAll('#toolProperties .control-group');
             allToolProperties.forEach(group => {
                 group.style.display = 'none';
             });

             // Helper function to safely show element
             function safeShowElement(elementId) {
                 const element = document.getElementById(elementId);
                 if (element) {
                     element.style.display = 'block';
                 }
             }

             // Show the relevant properties based on tool type
             switch(toolType) {
                 case 'arrow':
                     safeShowElement('arrowProperties');
                     break;
                 case 'brush':
                     safeShowElement('brushProperties');
                     break;
                 case 'text':
                     safeShowElement('textProperties');
                     break;
                 case 'shape':
                     safeShowElement('shapeProperties');
                     break;
                 case 'eraser':
                     safeShowElement('eraserProperties');
                     break;
                 case 'crop':
                     safeShowElement('cropProperties');
                     break;
                 case 'clone':
                     safeShowElement('cloneProperties');
                     break;
                 case 'blur':
                     safeShowElement('blurToolProperties');
                     break;
                 case 'sharpen':
                     safeShowElement('sharpenToolProperties');
                     break;
                 case 'dodge':
                     safeShowElement('dodgeProperties');
                     break;
                 case 'burn':
                     safeShowElement('burnProperties');
                     break;
                 case 'sponge':
                     safeShowElement('spongeProperties');
                     break;
                 case 'gradient':
                     safeShowElement('gradientProperties');
                     break;
                 case 'bucket':
                     safeShowElement('bucketProperties');
                     break;
                 case 'eyedropper':
                     safeShowElement('eyedropperProperties');
                     break;
             }

             // Open the Tool Properties panel
             openToolPropertiesPanel();
         }
    </script>
</body>
</html>
